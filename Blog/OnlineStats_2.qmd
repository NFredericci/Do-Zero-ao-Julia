---
title: "Estatísticas Incrementais em Julia com OnlineStats.jl - Parte 2"
description: |
  Um guia prático para usar OnlineStats.jl em Julia, realizando estatísticas via streaming e algoritmos online com memória constante.
categories:
  - Estatística
author:
  - name: Caio Frare
    affiliation: "Universidade Estadual de Campinas"
    url: https://github.com/caiofrare
  - name: Carlos Trucíos
    affiliation: "Universidade Estadual de Campinas"
    url: https://ctruciosm.github.io
    orcid: 0000-0001-8746-8877
date: "2025-10-23"
image: imagens/estat_incrementais_2.png
lang: pt
format:
  html:
    toc: true
    toc-depth: 3
    self-contained: false
engine: knitr
draft: true
---

## Introdução

::: justify
Na Parte 1
 deste blog, conhecemos as bases do pacote `OnlineStats.jl`, uma poderosa ferramenta da linguagem Julia voltada ao cálculo de estatísticas de forma incremental — isto é, sem precisar carregar todo o conjunto de dados na memória.

Agora, nesta Parte 2, vamos explorar funcionalidades mais avançadas do pacote, ideais para aplicações em grandes volumes de dados, análises de logs contínuos e fluxos de dados em tempo real.
Além disso, veremos como o `OnlineStats.jl` pode ser aplicado em tarefas de regressão linear em larga escala, análise incremental de arquivos CSV gigantes e até mesmo integração com streams ao vivo usando Channels e Tasks.

Se você já trabalha com dados dinâmicos, esta é uma oportunidade de entender como a linguagem Julia lida com estatísticas de forma eficiente, escalável e elegante.
:::

## Regressão em Grandes Datasets

:::justify
Um dos recursos mais interessantes do OnlineStats.jl é a capacidade de realizar ajustes de regressão linear de forma incremental — processando milhões de observações sem precisar armazená-las em memória.
Para isso, podemos usar os tipos LinReg ou LinRegBuilder.

O exemplo abaixo mostra como atualizar um modelo de regressão linha a linha:
:::

```{julia}
using OnlineStats, Random

Random.seed!(123)

# Simula dados (5 preditores)
for n in (1000, 10000)
    X = randn(n, 5)
    β = 1:5
    y = X * β .+ 0.1*randn(n)
    model = fit!(LinReg(), zip(eachrow(X), y))
    println("n = $n, coef = ", coef(model))
end

```

:::justify
No exemplo, `fit!` atualiza o modelo a cada linha, sem precisar reprocessar o conjunto completo.
Já o LinRegBuilder é mais conveniente quando se deseja ajustar o modelo diretamente a partir de uma matriz:
:::

```{julia}

# Gerando dados simulados
n = 100_000
p = 10
X = [randn(p) for _ in 1:n]              # Lista de vetores de features
β = range(-1, 1, length=p)               # Coeficientes reais
y = [dot(x, β) + 0.1*randn() for x in X] # Resposta linear + ruído

# Criando o modelo de regressão
o = LinRegBuilder(p)

# Alimentando incrementalmente com [x; y]
for (xi, yi) in zip(X, y)
    fit!(o, [xi; yi])   # concatenamos o vetor de features com o target
end

# Resultados
println("Coeficientes estimados:")
println(coef(o))

```

:::justify
Essas abordagens são ideais para contextos de big data e permitem que os coeficientes sejam atualizados em tempo real, sem depender de frameworks externos.
:::

## Análise Incremental de Logs e Arquivos CSV

:::justify
Outra aplicação prática do OnlineStats.jl é a análise de logs ou bases tabulares muito grandes, como arquivos CSV de gigabytes.
Combinando CSV.Rows e GroupBy, é possível calcular estatísticas agregadas sem sobrecarregar a memória.

O exemplo a seguir mostra como gerar histogramas de forma incremental a partir de um dataset público:
:::

```{julia}
using CSV, Downloads, Plots

# Baixando o dataset Iris
url = "https://gist.githubusercontent.com/netj/8836201/raw/6f9306ad21398ea43cba4f7d537619d0e07d5ae3/iris.csv"
file_path = Downloads.download(url)

# Leitura com normalizenames=true para padronizarmos o nome das colunas
rows = CSV.Rows(file_path; reusebuffer=true, normalizenames=true)

# GroupBy: chave String -> Hist
o = GroupBy(String, Hist(0:0.5:8))

# Preenchemos convertendo a chave para lowercase (para consistência)
for row in rows
    key = lowercase(string(row.variety))                  # ex: "setosa"
    val = tryparse(Float64, string(row.sepal_length))    # garante Float64
    if val === nothing || val === missing
        continue
    end
    fit!(o, key => val)
end

# Função robusta para extrair arestas e contagens de diferentes versões de Hist
function edges_and_counts(h)
    # tenta obter edges
    e = nothing
    if :edges in fieldnames(typeof(h))
        e = getfield(h, :edges)
    elseif hasmethod(edges, Tuple{typeof(h)})
        e = edges(h)
    end

    # tenta obter contagens (weights/counts/...) por campos ou funções
    c = nothing
    for name in (:weights, :counts, :w, :bins)
        if name in fieldnames(typeof(h))
            c = getfield(h, name)
            break
        end
    end
    if c === nothing
        if hasmethod(weights, Tuple{typeof(h)})
            c = weights(h)
        elseif hasmethod(counts, Tuple{typeof(h)})
            c = counts(h)
        end
    end

    if e === nothing || c === nothing
        println("Campos disponíveis em Hist: ", fieldnames(typeof(h)))
        error("Não foi possível extrair arestas ou contagens do Hist na sua versão do pacote.")
    end

    return e, c
end

# Acessa o histograma da espécie "setosa"
hist_setosa = o["setosa"]
println("Histograma (raw): ", hist_setosa)

# Obtém arestas e contagens de forma compatível e plota
edges, counts = edges_and_counts(hist_setosa)
bar(edges[1:end-1], counts,
    label="Setosa", xlabel="Comprimento da Sépala", ylabel="Frequência")
```


:::justify
Aqui, cada variedade de flor (setosa, versicolor, virginica) mantém seu próprio histograma, atualizado linha a linha — uma técnica extremamente útil para lidar com logs de usuários, eventos de rede ou métricas de sistemas.
:::

## Processamento de Fluxos de Dados ao Vivo

:::justify
Uma das forças da linguagem Julia está na sua concorrência leve via Tasks e Channels.
Isso permite integrar o OnlineStats.jl a fluxos de dados contínuos — simulando, por exemplo, sensores, filas de mensagens ou requisições de API em tempo real.

Veja como isso pode ser feito com um simples padrão produtor-consumidor:
:::

```{julia}

Random.seed!(42)
ch = Channel{Tuple{Vector{Float64}, Float64}}(32)

model = LinReg()

# Produtor
producer = @async begin
    for i in 1:5000
        x = randn(5)
        y = dot(x, 1:5) + 0.2*randn()
        put!(ch, (x, y))
    end
    close(ch)
end

# Consumidor
consumer = @async begin
    for (x,y) in ch
        fit!(model, (x, y))
    end
end

wait(consumer)
println("Coeficientes finais: ", coef(model))

```

:::justify
Com isso, o modelo é treinado continuamente conforme os dados chegam, sem precisar interromper o fluxo.
Esse padrão é útil para aplicações como monitoramento de desempenho, análise em tempo real de sensores IoT ou atualização de métricas de plataformas online.
:::

## Combinação e Paralelização

:::justify
O OnlineStats também permite mesclar estatísticas calculadas em diferentes partes do sistema — ideal para pipelines distribuídos.
:::

```{julia}
using Distributed

a = fit!(Mean(), randn(1000))
b = fit!(Mean(), randn(1000))
merge!(a, b)
println("Média combinada: ", value(a))

```

:::justify
Essa capacidade de agregação faz com que o pacote seja facilmente integrável com fluxos paralelos, sistemas distribuídos e arquiteturas baseadas em sharding.
:::

## Conclusão

:::justify
O OnlineStats.jl vai muito além de uma simples ferramenta de cálculo de média e variância.
Ele é uma infraestrutura completa para análise incremental e em tempo real, ideal para lidar com dados que chegam em fluxo constante ou que simplesmente não cabem na memória.

Nesta segunda parte, vimos como aplicar o pacote para:

Ajustar regressões lineares em grandes datasets;

Processar arquivos CSV e logs gigantes sem sobrecarregar o sistema;

Integrar modelos e métricas a fluxos de dados contínuos;

Combinar resultados parciais com merge! em pipelines distribuídos.

Se na Parte 1 exploramos a base do pensamento online, nesta Parte 2 você conheceu o poder de escalar essa lógica para aplicações do mundo real — de análise de logs a sistemas de aprendizado incremental.

Na próxima parte (Parte 3), poderemos explorar visualizações dinâmicas e integrações com dashboards para monitorar estatísticas em tempo real. 
:::

::: callout-note
Ferramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto.
:::