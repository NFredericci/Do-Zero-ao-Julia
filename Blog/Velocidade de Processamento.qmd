---
title: "Velocidade de Processamento: R vs Julia vs Python"
description: |
   Para quem lida com grandes volumes de dados ou cálculos complexos, conhecer a velocidade de execução das linguagens é fundamental. Neste post, comparamos `R`, `Julia` e `Python` por meio de uma função de Fibonacci, mostrando como a escolha da linguagem pode fazer diferença no tempo de processamento e na produtividade.
categories:
  -  Benchmark
author:
  - name: Gabriel Campovilla da Silva
    affiliation: "Universidade Estadual de Campinas"
    url: https://github.com/C4mpovill4
  - name: Nicole Fredericci
    affiliation: "Universidade Estadual de Campinas"
    url: https://github.com/NFredericci
date: "2025-09-19"
image: imagens/velo.jpeg
lang: "pt"
format:
  html:
    toc: true
    self-contained: false
draft: false
---

```{r}
#| echo: false
Sys.setenv(JULIA_HOME = "/Users/ctrucios/.juliaup/bin")
```



## Introdução

:::{.justify}
Em uma linguagem interpretada, o código é processado linha a linha por um interpretador, o que facilita a execução de testes rápidos, execução de trechos isolados e depuração (mas reduz a velocidade em operações intensivas). Já em linguagens com compilação _Just-In-Time (JIT)_, o interpretador compila trechos do código em linguagem de máquina durante a execução, em vez de interpretar linha a linha o tempo todo, permitindo um desempenho próximo a linguagens compiladas (especialmente em loops e cálculos intensivos). E quando se procura uma linguagem de programação para análise de dados ou computação científica, a velocidade de processamento pode influenciar bastante a escolha. Neste post, comparamos três linguagens populares — `R`, `Julia` e `Python` — analisando seu desempenho em uma tarefa computacionalmente intensiva.
:::

## Por que a velocidade difere?

:::{.justify}
-   **Python**: Linguagem interpretada e dinâmica, o que geralmente a torna mais lenta. No entanto, bibliotecas como `NumPy` e `Pandas` usam implementações em `C` e `Fortran`, permitindo um bom desempenho em operações numéricas.

-   **R**: Também é interpretada e foi criada para atender ao público da estatística. Loops puros são lentos, mas funções vetorizadas e pacotes como `data.table` e `dplyr` oferecem bom desempenho.

-   **Julia**: Projetada para alta performance, atinge velocidades próximas às de `C` e `Fortran` sem depender de bibliotecas externas, graças à sua compilação _JIT_. Vale notar que `Python` e `R` também podem alcançar desempenho semelhante usando ferramentas que compilam partes do código em `C`, como `Cython` (uma extensão para Python) e `Rcpp` (um pacote para R).
:::

## Exemplo Prático: Cálculo de Fibonacci

:::{.justify}
Para evidenciar a diferença de desempenho bruto entre as três linguagens, implementamos uma função recursiva de Fibonacci (propositalmente ineficiente), com o objetivo de testar a velocidade de processamento. Os resultados apresentados foram obtidos em um MacBook equipado com Apple M3 Pro e 18 GB de RAM.
:::

**R**

```{r}
fib <- function(n) {
    if (n <= 1) {
        return(n)
    } else {
        return(fib(n-1) + fib(n-2))
    }
}
```




:::: {.columns}

::: {.column width="50%"}
```{r}
start <- Sys.time()
result <- fib(30)
end <- Sys.time()

print(paste("Resultado:", result))
print(paste("Tempo R:", end - start))
```
:::


::: {.column width="50%"}
```{r}
start <- Sys.time()
result <- fib(40)
end <- Sys.time()

print(paste("Resultado:", result))
print(paste("Tempo R:", end - start))
```
:::
::::





**Julia**

```{julia}
function fib(n)
    if n <= 1
        return n
    else
        return fib(n-1) + fib(n-2)
    end
end
```


:::: {.columns}

::: {.column width="50%"}
```{julia}
start_time = time();
result = fib(30);
end_time = time();

println("Resultado: $result")
println("Tempo Julia: $(end_time - start_time) segundos")
```
:::



::: {.column width="50%"}
```{julia}
start_time = time();
result = fib(40);
end_time = time();

println("Resultado: $result")
println("Tempo Julia: $(end_time - start_time) segundos")
```
:::
::::





**Python**

```{python}
import time

def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)
```



:::: {.columns}

::: {.column width="50%"}
```{python}
start = time.time()
result = fib(30)
end = time.time()

print(f"Resultado: {result}")
print(f"Tempo Python: {end - start:.4f} segundos")
```
:::


::: {.column width="50%"}
```{python}
start = time.time()
result = fib(40)
end = time.time()

print(f"Resultado: {result}")
print(f"Tempo Python: {end - start:.4f} segundos")
```
:::
::::



## Resultados Esperados

:::{.justify}
Os tempos de execução podem variar de execução para execução e dependendo do computador sendo utilizado. Para padronizar um pouco os resultados, utilizando a consiguração padrão do Colab e realizamos os testes  para `fib(40)` os valores encontrados foram:

-   **Julia**: 1,45 segundos.

-   **Python**: 23,13 segundos.

-   **R**: 159,51 segundos.
:::

## Conclusão

:::{.justify}
Os testes com a função recursiva de Fibonacci ilustram claramente as diferenças de desempenho entre as linguagens. Embora `Julia` se destaque em cálculos computacionalmente intensivos devido à sua compilação _JIT_, a escolha da linguagem deve levar em conta também o ecossistema, a familiaridade do usuário e o tipo de análise a ser realizada. 

`Python` oferece equilíbrio entre desempenho e facilidade de uso, enquanto `R` continua sendo a opção ideal para análises estatísticas específicas, com sintaxe concisa e pacotes robustos, apesar de mais lento em cálculos brutos. 
:::

::: callout-note
Ferramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto.
:::
