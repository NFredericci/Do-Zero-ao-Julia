[
  {
    "objectID": "Q&A.html",
    "href": "Q&A.html",
    "title": "Perguntas e Respostas",
    "section": "",
    "text": "Julia é uma linguagem de programação cada vez mais popular em análise numérica, estatística, econometria, machine learning e ciência de dados. Suas principais vantagens incluem:\n\nDesempenho e Velocidade: Julia foi projetada para alto desempenho, muitas vezes igualando ou superando C e Fortran, sem perder a facilidade de uso de Python ou R.\nSintaxe Simples: A sintaxe é amigável, tornando a linguagem acessível para alunos e pesquisadores vindos de R, Python ou MATLAB.\nInteroperabilidade: Julia pode chamar código em Python, R e C/Fortran, permitindo integração fácil com projetos já existentes.\nComputação Paralela e Distribuída: Julia possui suporte nativo para multi-threading e computação distribuída, ideal para simulações em larga escala.\nAdoção Crescente: Julia tem ganhado espaço em universidades e centros de pesquisa no mundo todo, com um ecossistema em constante expansão."
  },
  {
    "objectID": "Q&A.html#por-que-julia",
    "href": "Q&A.html#por-que-julia",
    "title": "Perguntas e Respostas",
    "section": "",
    "text": "Julia é uma linguagem de programação cada vez mais popular em análise numérica, estatística, econometria, machine learning e ciência de dados. Suas principais vantagens incluem:\n\nDesempenho e Velocidade: Julia foi projetada para alto desempenho, muitas vezes igualando ou superando C e Fortran, sem perder a facilidade de uso de Python ou R.\nSintaxe Simples: A sintaxe é amigável, tornando a linguagem acessível para alunos e pesquisadores vindos de R, Python ou MATLAB.\nInteroperabilidade: Julia pode chamar código em Python, R e C/Fortran, permitindo integração fácil com projetos já existentes.\nComputação Paralela e Distribuída: Julia possui suporte nativo para multi-threading e computação distribuída, ideal para simulações em larga escala.\nAdoção Crescente: Julia tem ganhado espaço em universidades e centros de pesquisa no mundo todo, com um ecossistema em constante expansão."
  },
  {
    "objectID": "Q&A.html#por-que-na-unicamp",
    "href": "Q&A.html#por-que-na-unicamp",
    "title": "Perguntas e Respostas",
    "section": "2. Por que na UNICAMP?",
    "text": "2. Por que na UNICAMP?\nOportunidade de Crescimento: Julia ainda é relativamente nova em comparação com R e Python. A UNICAMP pode se tornar um polo de referência no Brasil e na América Latina para sua adoção."
  },
  {
    "objectID": "Q&A.html#a-participação-no-projeto-contará-créditos",
    "href": "Q&A.html#a-participação-no-projeto-contará-créditos",
    "title": "Perguntas e Respostas",
    "section": "3. A participação no projeto contará créditos?",
    "text": "3. A participação no projeto contará créditos?\n\nAlunos da Graduação: Sim! No 2025-II será aberta uma disciplina chamada Tópicos de Extensão (ME881) valendo 5 créditos (equivalente a 75 horas dedicadas ao projeto).\nAlunos da Pós-graduação: Não! (mas colocar no lattes uma participação em projetos de extensão não parece ser uma ideia ruim)"
  },
  {
    "objectID": "Q&A.html#quantas-horas-por-semana-devo-dedicar-ao-projeto",
    "href": "Q&A.html#quantas-horas-por-semana-devo-dedicar-ao-projeto",
    "title": "Perguntas e Respostas",
    "section": "4. Quantas horas por semana devo dedicar ao projeto?",
    "text": "4. Quantas horas por semana devo dedicar ao projeto?\nOriginalmente, o projeto foi pensado para o aluno se dedicar, em média, 10 horas semanais ao projeto, totalizando, aproximadamente, 40 horas num semestre letivo. Contudo, como a disciplina a ser aberta equivale a 75 horas dedicadas ao projeto, o aluno(a) deverá acumular, pelo menos, 75 horas de dedicação ao projeto no final do 2025-II para ser aprovado na disciplina."
  },
  {
    "objectID": "Q&A.html#se-são-75-horas-como-será-feito-isso",
    "href": "Q&A.html#se-são-75-horas-como-será-feito-isso",
    "title": "Perguntas e Respostas",
    "section": "5. Se são 75 horas, como será feito isso?",
    "text": "5. Se são 75 horas, como será feito isso?\nExistem duas formas:\n\nO aluno(a) se matricula na disciplina no 2025-II e durante o semestre precisará se dedicar, aproximadamente, 19 horas semanais ao projeto (o que é quase impossível, exceto se estiver cursando apenas uma ou duas disciplinas)\nO aluno(a) começa a trabalhar desde agora, vá acumulando horas e no próximo semestre se matricula normalmente na disciplina e continua trabalhando no projeto até cumprir o número de horas necessárias (opção mais viável e realista)."
  },
  {
    "objectID": "Q&A.html#blz-mas-como-serão-contabilizadas-essas-horas",
    "href": "Q&A.html#blz-mas-como-serão-contabilizadas-essas-horas",
    "title": "Perguntas e Respostas",
    "section": "6. Blz, mas como serão contabilizadas essas horas?",
    "text": "6. Blz, mas como serão contabilizadas essas horas?\nCriei uma tabela de equivalência entre as atividades realizadas e o número de horas a serem computadas e tanto o aluno quanto o professor manterão um registro destas atividades. A tabela de equivalências é dada a seguir:\n\n\n\nAtividade\nHoras a serem computadas\n\n\n\n\n1 Post no Blog\n3 horas\n\n\n1 Tutorial\n6 horas\n\n\n1 Minicurso\n14 horas*\n\n\n1 Meetup organizado\n2 horas\n\n\nCuidar do Instagram\n10 horas*\n\n\nOutros\na combinar\n\n\n\n*: para ser feito em dupla\n\nO minicurso deverá ser de aproximadamente 5-6 horas e será no formato online.\nO cuidado do instagram inclui a criação das artes (cartaz, fotos, etc) e as postagens na própria rede social durante todo o semestre.\n\nAssim, por exemplo:\n\nUm aluno que no 2025-I escreve 4 posts no semestre, 2 tutoriais, 1 minicurso e organiza um meetup, lhe serão computadas \\(4 \\times 3 + 2 \\times 6 + 14 + 2 = 40\\) horas\nUm aluno que no 2025-I escreve 10 post, e organiza um meetup, lhe serão computadas \\(10 \\times 3 +  2 = 32\\) horas\n\n\n\n\n\n\n\nBonificação\n\n\n\n\nAo iniciar o projeto, o aluno(a) deverá aprender a trabalhar com Github, Quarto e Julia. Assim, para considerar este tempo de aprendizagem, cada aluno(a) receberá uma única vez uma bonificação de 5 horas a serem computadas (desde que acumule, pelo menos, 30 hora já dedicadas ao projeto).\nSe o Instagram receber mais de 1000 novos seguidores no semestre, todos os alunos serão bonificados com 5 horas a serem computadas."
  },
  {
    "objectID": "Q&A.html#quais-são-os-temas-para-os-posts-tutoriais-minicursos-etc",
    "href": "Q&A.html#quais-são-os-temas-para-os-posts-tutoriais-minicursos-etc",
    "title": "Perguntas e Respostas",
    "section": "7. Quais são os temas para os posts, tutoriais, minicursos, etc?",
    "text": "7. Quais são os temas para os posts, tutoriais, minicursos, etc?\nNão existe uma roteiro definido, mas todos esses assuntos serão definidos nas reuniões das sextas-feiras (que serão quinzenalmente)."
  },
  {
    "objectID": "Q&A.html#as-reuniões-das-sextas-são-obrigatórias",
    "href": "Q&A.html#as-reuniões-das-sextas-são-obrigatórias",
    "title": "Perguntas e Respostas",
    "section": "8. As reuniões das sextas são obrigatórias?",
    "text": "8. As reuniões das sextas são obrigatórias?\nSim! as reuniões são de alinhamento, para definir as metas para os próximos 15 dias e evitar posts/tutoriais repetidos."
  },
  {
    "objectID": "Q&A.html#existe-algúm-material-específico-a-seguir",
    "href": "Q&A.html#existe-algúm-material-específico-a-seguir",
    "title": "Perguntas e Respostas",
    "section": "9. Existe algúm material específico a seguir?",
    "text": "9. Existe algúm material específico a seguir?\nNão, mas na elaboração dos posts, tutoriais e minicursos (todos em português), os alunos utilizarão recursos como:\n\nThink Julia: How to Think Like a Computer Scientist\nJulia for High Performance Scientific Computing\nPractical Julia\nUsing Julia for introductory Econometrics\nJulia for Data Analysis\nJulia Academy\nDocumentação oficial de Julia."
  },
  {
    "objectID": "Q&A.html#uma-última-coisa",
    "href": "Q&A.html#uma-última-coisa",
    "title": "Perguntas e Respostas",
    "section": "10. Uma última coisa",
    "text": "10. Uma última coisa\nEntre as atividades a serem realizadas pelos envolvidos temos:\n\nManutenção do Website e alimentação das redes sociais\nOrganização dos Meetup online\nElaboração de conteúdo para o blog\nElaboração dos tutoriais\nElaboração de minicursos (1 por semestre)\nElaboração de material para divulgação\n\n\nAs reuniões de coordenação e planejamento semanal acontecerão sextas-feiras às 9:00 da manhã.\n\n\nAlém de aprender e ensinar uma nova linguagem de programação com grande potencial na academia e na indústria, o projeto contribui para uma sociedade mais envolvida com a tecnologia, promovendo a equidade de gênero, raça e condição social nas áreas de STEM e disciplinas relacionadas. Os alunos envolvidos também terão a oportunidade de desenvolver suas habilidades de comunicação oral e escrita, soft skills essenciais para o mundo atual.\n\n\nInteressado(a) em fazer parte do projeto? Entre em contato via email com o coordenador do projeto, Prof. Carlos Trucíos."
  },
  {
    "objectID": "Equipe/Antigos/adriel.html",
    "href": "Equipe/Antigos/adriel.html",
    "title": "Adriel Wesley Nascimento Melo",
    "section": "",
    "text": "Lattes\n  \n\n\n\nMestrando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Antigos/pedro.html",
    "href": "Equipe/Antigos/pedro.html",
    "title": "Pedro Henrique Galera Elias",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n  \n    \n     Lattes\n  \n\n\n\nMestrando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/Ana_Luisa.html",
    "href": "Equipe/Atual/Ana_Luisa.html",
    "title": "Ana Luisa Pereira da Silva Rodrigues",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n\n      \nGraduando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/carlos_trucios.html",
    "href": "Equipe/Atual/carlos_trucios.html",
    "title": "Carlos Trucíos",
    "section": "",
    "text": "Website\n  \n  \n    \n     Lattes\n  \n  \n    \n     Scholar\n  \n  \n    \n     Github\n  \n  \n    \n     Linkedin\n  \n\n      \n\n    \n    \n  \n\n\nCoordenador do projeto e Professor do Departamento de Estatística do IMECC desde 2022.\n\nSala: 206 - IMECC\nE-mail: ctrucios at unicamp dot br"
  },
  {
    "objectID": "Equipe/Atual/pedro_galera.html",
    "href": "Equipe/Atual/pedro_galera.html",
    "title": "Pedro H. G. Elias",
    "section": "",
    "text": "Lattes\n  \n  \n    \n     Github\n  \n  \n    \n     Linkedin\n  \n\n      \n\n    \n    \n  \n\n\nDoutorando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/esther_cleveston.html",
    "href": "Equipe/Atual/esther_cleveston.html",
    "title": "Esther Cleveston",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n\n      \nGraduando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/guiduarte.html",
    "href": "Equipe/Atual/guiduarte.html",
    "title": "Guilherme Duarte Alves Basso",
    "section": "",
    "text": "Graduando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/nicole_fredericci.html",
    "href": "Equipe/Atual/nicole_fredericci.html",
    "title": "Nicole Fredericci",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n\n      \n\n    \n    \n  \n\n\nGraduanda em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/gabriel_cardoso.html",
    "href": "Equipe/Atual/gabriel_cardoso.html",
    "title": "Gabriel Vieira Cardoso",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n\n      \nGraduando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/vitor_ribas.html",
    "href": "Equipe/Atual/vitor_ribas.html",
    "title": "Vitor Ribas Perrone",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n\n      \n\n    \n    \n  \n\n\nGraduando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Blog/Perspectivas.html",
    "href": "Blog/Perspectivas.html",
    "title": "Perspectivas de Julia para o Futuro",
    "section": "",
    "text": "Julia surgiu como uma proposta de unir a simplicidade de linguagens como R e Python ao desempenho de linguagens de alto rendimento, como Fortran e C. Desde o lançamento de sua versão mais estável, a linguagem tem ganhado espaço nos rankings de popularidade, atingindo, em 2022, a 21ª posição.\nMas qual será o alcance dessa linguagem nos próximos anos? Quais são as perspectivas de uso de Julia para o futuro?"
  },
  {
    "objectID": "Blog/Perspectivas.html#a-linguagem",
    "href": "Blog/Perspectivas.html#a-linguagem",
    "title": "Perspectivas de Julia para o Futuro",
    "section": "",
    "text": "Julia surgiu como uma proposta de unir a simplicidade de linguagens como R e Python ao desempenho de linguagens de alto rendimento, como Fortran e C. Desde o lançamento de sua versão mais estável, a linguagem tem ganhado espaço nos rankings de popularidade, atingindo, em 2022, a 21ª posição.\nMas qual será o alcance dessa linguagem nos próximos anos? Quais são as perspectivas de uso de Julia para o futuro?"
  },
  {
    "objectID": "Blog/Perspectivas.html#crescimento-expressivo",
    "href": "Blog/Perspectivas.html#crescimento-expressivo",
    "title": "Perspectivas de Julia para o Futuro",
    "section": "Crescimento expressivo",
    "text": "Crescimento expressivo\n\nO crescimento da linguagem Julia tem sido constante ao longo dos anos, impulsionado pela criação de um número cada vez maior de pacotes (bibliotecas), bem como pelo aumento de fóruns e comunidades. Atualmente, o software de Julia já foi baixado mais de 40 milhões de vezes, ocupando, em 2022, as posições 25ª e 21ª nos índices PYPL e TIOBE, respectivamente.\nAlém disso, a linguagem tem ganhado destaque em pesquisas científicas, principalmente nas áreas de engenharia e ciências exatas, resultado combinado à criação de cerca de 8.000 pacotes para a linguagem, disponíveis para a comunidade."
  },
  {
    "objectID": "Blog/Perspectivas.html#desafios-enfrentados",
    "href": "Blog/Perspectivas.html#desafios-enfrentados",
    "title": "Perspectivas de Julia para o Futuro",
    "section": "Desafios enfrentados",
    "text": "Desafios enfrentados\n\nApesar dos avanços, como ocorre em toda linguagem de programação, Julia ainda enfrenta alguns desafios. Entre eles, destaca-se a dificuldade de adoção no mercado tradicional, devido à consolidação de outras linguagens. Outro obstáculo relevante está relacionado ao tempo de compilação: o compilador Just-in-Time (JIT) de Julia pode gerar um atraso perceptível na primeira execução de determinados pacotes. Esse comportamento pode impactar a experiência de novos usuários e limitar, em parte, sua implementação em aplicações que demandam maior agilidade."
  },
  {
    "objectID": "Blog/Perspectivas.html#o-futuro",
    "href": "Blog/Perspectivas.html#o-futuro",
    "title": "Perspectivas de Julia para o Futuro",
    "section": "O futuro",
    "text": "O futuro\n\nTodo esse crescimento constante e expressivo nos últimos anos aponta para um futuro promissor para a linguagem, com um grande potencial para o desenvolvimento de ferramentas e pacotes. Embora existam desafios para sua integração em diferentes áreas, o ritmo acelerado de desenvolvimento mostra que Julia não é apenas uma tendência passageira — a linguagem tem tudo para conquistar cada vez mais espaço e popularidade no cenário da programação."
  },
  {
    "objectID": "Blog/Perspectivas.html#referências-utilizadas-para-a-construção-do-texto",
    "href": "Blog/Perspectivas.html#referências-utilizadas-para-a-construção-do-texto",
    "title": "Perspectivas de Julia para o Futuro",
    "section": "Referências utilizadas para a construção do texto",
    "text": "Referências utilizadas para a construção do texto\n\n\nO que é Julia? Coodesh, 2025. Disponível em: https://coodesh.com/blog/dicionario/o-que-e-julia. Acesso em: 20 maio 2025.\nConheça a linguagem de programação cada vez mais usada no MIT. Canaltech, 2022. Disponível em: https://canaltech.com.br/carreira/julia. Acesso em: 01 junho 2025.\nJulia vs Python - Qual você deve aprender? DataCamp, 2024. Disponível em: https://www.datacamp.com/pt/blog/julia-vs-python. Acesso em: 01 junho 2025.\nSTOROPOLI, José; HUIJZER, Rik; ALONSO, Lazaro D. Julia Data Science. Disponível em: https://juliadatascience.io/pt/julia_accomplish.\n\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/datas.html",
    "href": "Blog/datas.html",
    "title": "Manipulação de datas em Julia",
    "section": "",
    "text": "Manipular datas é essencial em diversas áreas da Estatística aplicada, como análise de séries temporais, estudos de sobrevivência, dados em painel, entre outras. Para isso, Julia oferece diversas ferramentas para trabalhar com datas de forma eficiente.\nNeste post, vamos explorar como trabalhar com datas e horários em Julia utilizando o módulo Dates, que já faz parte da biblioteca padrão da linguagem. Você aprenderá a criar, manipular, extrair informações e realizar operações com objetos do tipo data."
  },
  {
    "objectID": "Blog/datas.html#introdução",
    "href": "Blog/datas.html#introdução",
    "title": "Manipulação de datas em Julia",
    "section": "",
    "text": "Manipular datas é essencial em diversas áreas da Estatística aplicada, como análise de séries temporais, estudos de sobrevivência, dados em painel, entre outras. Para isso, Julia oferece diversas ferramentas para trabalhar com datas de forma eficiente.\nNeste post, vamos explorar como trabalhar com datas e horários em Julia utilizando o módulo Dates, que já faz parte da biblioteca padrão da linguagem. Você aprenderá a criar, manipular, extrair informações e realizar operações com objetos do tipo data."
  },
  {
    "objectID": "Blog/datas.html#criação-de-objetos-de-data",
    "href": "Blog/datas.html#criação-de-objetos-de-data",
    "title": "Manipulação de datas em Julia",
    "section": "Criação de objetos de data",
    "text": "Criação de objetos de data\n\nEm primeiro lugar, é necessário carregar o módulo Dates, que já está presente na instalação padrão do Julia.\n\n\nusing Dates\n\n\nExistem duas principais estruturas para representar datas em Julia:\n\nDate: representa apenas a data (ano, mês e dia).\nDateTime: representa data e hora, incluindo minutos, segundos, etc.\n\nPodemos criar cada uma dessas estruturas por meio de funções de mesmo nome.\n\n\nDate(2013, 3, 25)\n\n2013-03-25\n\nDateTime(2013, 3, 25)\n\n2013-03-25T00:00:00\n\n\n\nVocê também pode criar esses objetos a partir de uma String que siga o formato correspondente:\n\n\nDate(\"2015-03-25\", dateformat\"y-m-d\")\n\n2015-03-25\n\nDate(\"2015-25-03\", dateformat\"y-d-m\")\n\n2015-03-25\n\nDateTime(\"2015/03/25 14:30\", dateformat\"y/m/d HH:MM\")\n\n2015-03-25T14:30:00\n\n\n\nPara obter a data e hora atual do sistema, podemos utilizar as funções today e now.\n\n\ntoday() # Retorna apenas a data atual\n\n2025-09-19\n\nnow()   # Retorna data e hora completas\n\n2025-09-19T12:04:26.202"
  },
  {
    "objectID": "Blog/datas.html#acessar-partes-específicas-da-data",
    "href": "Blog/datas.html#acessar-partes-específicas-da-data",
    "title": "Manipulação de datas em Julia",
    "section": "Acessar partes específicas da data",
    "text": "Acessar partes específicas da data\n\nExistem funções que permitem extrair partes específicas de uma data. Para exemplificar, vamos criar um objeto chamado data.\n\n\ndata = Date(\"2015-03-25\", dateformat\"y-m-d\")\n\n2015-03-25\n\n\n\nÉ possível extrair partes específicas de uma data utilizando funções que têm o mesmo nome dessas partes, como year(), month() e day().\n\n\nyear(data)  # Retorna o ano\n\n2015\n\nmonth(data) # Retorna o mês\n\n3\n\nday(data)   # Retorna o dia\n\n25\n\n\n\nTambém existem funções que retornam múltiplos componentes de uma vez, como yearmonth e yearmonthday.\n\n\nyearmonth(data)     # Retorna ano e mês\n\n(2015, 3)\n\nyearmonthday(data)  # Retorna ano, mês e dia\n\n(2015, 3, 25)\n\n\n\nAlém de extrair elementos numéricos da data, também é possível obter informações em texto, como o nome do dia da semana e o nome do mês.\n\n\ndayname(data)\n\n\"Wednesday\"\n\nmonthname(data)\n\n\"March\""
  },
  {
    "objectID": "Blog/datas.html#informações-de-calendário",
    "href": "Blog/datas.html#informações-de-calendário",
    "title": "Manipulação de datas em Julia",
    "section": "Informações de calendário",
    "text": "Informações de calendário\n\nTambém existem funções para verificar informações relacionadas ao calendário, como isleapyear, que indica se o ano é bissexto, e daysinmonth, que retorna o número de dias que aquele mês possui.\n\n\nisleapyear(data) \n\nfalse\n\ndaysinmonth(data)\n\n31"
  },
  {
    "objectID": "Blog/datas.html#períodos-de-tempo",
    "href": "Blog/datas.html#períodos-de-tempo",
    "title": "Manipulação de datas em Julia",
    "section": "Períodos de tempo",
    "text": "Períodos de tempo\n\nAlém disso, é possível criar objetos que representam períodos de tempo, os quais podem ser usados posteriormente em operações e manipulações com datas.\n\n\nYear(5)\n\n5 years\n\nDay(7)\n\n7 days\n\nNanosecond(200)\n\n200 nanoseconds"
  },
  {
    "objectID": "Blog/datas.html#operações-com-datas",
    "href": "Blog/datas.html#operações-com-datas",
    "title": "Manipulação de datas em Julia",
    "section": "Operações com datas",
    "text": "Operações com datas\n\nExistem diversas operações que podem ser realizadas com datas. Para ilustrar, utilizaremos os seguintes exemplos:\n\n\ndata1 = Date(2010, 11, 30) \n\n2010-11-30\n\ndata2 = Date(2011, 12, 25)\n\n2011-12-25\n\n\n\nPodemos calcular a diferença, em dias, entre duas datas distintas.\n\n\ndata2 - data1\n\n390 days\n\ndata1 - data2\n\n-390 days\n\n\n\nTambém podemos utilizar aqueles objetos que representam períodos de tempo para somar ou subtrair valores diretamente das datas.\n\n\ndata1\n\n2010-11-30\n\ndata1 + Day(7)\n\n2010-12-07\n\ndata1 - Year(2)\n\n2008-11-30\n\n\n\nAinda, é possível realizar a comparação direta entre duas datas, verificando se uma desigualdade é verdadeira ou não.\n\n\ndata1 &lt; data2\n\ntrue\n\n\n\nPor fim, também é possível criar intervalos entre duas datas, especificando a unidade de incremento, como dias ou anos.\n\n\ncollect(Date(2020, 03, 02):Day(1):Date(2020, 03, 10))  # Intervalo diário\n\n9-element Vector{Date}:\n 2020-03-02\n 2020-03-03\n 2020-03-04\n 2020-03-05\n 2020-03-06\n 2020-03-07\n 2020-03-08\n 2020-03-09\n 2020-03-10\n\n\n\ncollect(Date(2020, 03, 02):Year(1):Date(2025, 03, 02)) # Intervalo anual\n\n6-element Vector{Date}:\n 2020-03-02\n 2021-03-02\n 2022-03-02\n 2023-03-02\n 2024-03-02\n 2025-03-02"
  },
  {
    "objectID": "Blog/datas.html#conclusão",
    "href": "Blog/datas.html#conclusão",
    "title": "Manipulação de datas em Julia",
    "section": "Conclusão",
    "text": "Conclusão\n\nAgora você já sabe como criar, acessar, manipular e realizar operações com datas em Julia! Esse conhecimento é fundamental para análises estatísticas que envolvem o fator tempo, como, por exemplo, o estudo de séries temporais e dados em painel.\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/tidierdata.html",
    "href": "Blog/tidierdata.html",
    "title": "Introdução ao pacote TidierData.jl",
    "section": "",
    "text": "O TidierData.jl é um pacote da linguagem julia que traz uma abordagem familiar aos usuários do R, inspirado diretamente nos pacotes dplyr e tidyr. Ele permite manipular e transformar conjuntos de dados com uma sintaxe concisa e legível no estilo tidy.\nNeste post, vamos explorar como o TidierData.jl facilita tarefas comuns de manipulação de dados, como seleção, filtragem, agregações, junções e muito mais.\n\nPor trás das cortinas, o TidierData.jl é construído sobre o robusto DataFrames.jl, combinando a performance de julia com a ergonomia do tidyverse."
  },
  {
    "objectID": "Blog/tidierdata.html#carregando-o-dataset-mtcars",
    "href": "Blog/tidierdata.html#carregando-o-dataset-mtcars",
    "title": "Introdução ao pacote TidierData.jl",
    "section": "Carregando o dataset ‘mtcars’",
    "text": "Carregando o dataset ‘mtcars’\n\nusing RDatasets\n\nmtcars = dataset(\"datasets\", \"mtcars\")\n\n32×12 DataFrame\n Row │ Model              MPG      Cyl    Disp     HP     DRat     WT       QS ⋯\n     │ String31           Float64  Int64  Float64  Int64  Float64  Float64  Fl ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Mazda RX4             21.0      6    160.0    110     3.9     2.62      ⋯\n   2 │ Mazda RX4 Wag         21.0      6    160.0    110     3.9     2.875\n   3 │ Datsun 710            22.8      4    108.0     93     3.85    2.32\n   4 │ Hornet 4 Drive        21.4      6    258.0    110     3.08    3.215\n   5 │ Hornet Sportabout     18.7      8    360.0    175     3.15    3.44      ⋯\n   6 │ Valiant               18.1      6    225.0    105     2.76    3.46\n   7 │ Duster 360            14.3      8    360.0    245     3.21    3.57\n   8 │ Merc 240D             24.4      4    146.7     62     3.69    3.19\n  ⋮  │         ⋮             ⋮       ⋮       ⋮       ⋮       ⋮        ⋮        ⋱\n  26 │ Fiat X1-9             27.3      4     79.0     66     4.08    1.935     ⋯\n  27 │ Porsche 914-2         26.0      4    120.3     91     4.43    2.14\n  28 │ Lotus Europa          30.4      4     95.1    113     3.77    1.513\n  29 │ Ford Pantera L        15.8      8    351.0    264     4.22    3.17\n  30 │ Ferrari Dino          19.7      6    145.0    175     3.62    2.77      ⋯\n  31 │ Maserati Bora         15.0      8    301.0    335     3.54    3.57\n  32 │ Volvo 142E            21.4      4    121.0    109     4.11    2.78\n                                                   5 columns and 17 rows omitted\n\n\nfirst(mtcars, 5)\n\n5×12 DataFrame\n Row │ Model              MPG      Cyl    Disp     HP     DRat     WT       QS ⋯\n     │ String31           Float64  Int64  Float64  Int64  Float64  Float64  Fl ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Mazda RX4             21.0      6    160.0    110     3.9     2.62      ⋯\n   2 │ Mazda RX4 Wag         21.0      6    160.0    110     3.9     2.875\n   3 │ Datsun 710            22.8      4    108.0     93     3.85    2.32\n   4 │ Hornet 4 Drive        21.4      6    258.0    110     3.08    3.215\n   5 │ Hornet Sportabout     18.7      8    360.0    175     3.15    3.44      ⋯\n                                                               5 columns omitted"
  },
  {
    "objectID": "Blog/tidierdata.html#funções-macro",
    "href": "Blog/tidierdata.html#funções-macro",
    "title": "Introdução ao pacote TidierData.jl",
    "section": "Funções Macro",
    "text": "Funções Macro\n\nO pacote oferece mais de 40 funções macro, as quais podemos usar para manipular dados. A seguir, exploraremos algumas das principais funções e observaremos sua sintaxe de forma clara e concisa.\n\n\nusing TidierData, DataFrames\n\n# Exemplo com o dataset mtcars\n\n@chain mtcars begin\n    @mutate(Eficiencia = MPG / WT)\n    @filter(Cyl == 6)\n    @arrange(desc(\"Eficiencia\"))\n    @select(Model, MPG, WT, Eficiencia)\n    @slice(1:6)\nend\n\n6×4 DataFrame\n Row │ Model           MPG      WT       Eficiencia\n     │ String31        Float64  Float64  Float64\n─────┼──────────────────────────────────────────────\n   1 │ Mazda RX4          21.0    2.62      8.01527\n   2 │ Mazda RX4 Wag      21.0    2.875     7.30435\n   3 │ Ferrari Dino       19.7    2.77      7.11191\n   4 │ Hornet 4 Drive     21.4    3.215     6.6563\n   5 │ Merc 280           19.2    3.44      5.5814\n   6 │ Valiant            18.1    3.46      5.23121\n\n\n\n\nPrimeiramente, para quem já está familiarizado com a linguagem R, a função @chain() é similar ao pipeline %&gt;% ou |&gt;, usado para encadear várias operações em sequência no mesmo conjunto de dados.\nEm seguida, criamos a nova coluna Eficiencia no nosso dataset, definida como a razão entre as colunas MPG e WT.\nAlém disso, aplicamos restrições à saída do dataset, filtrando apenas os carros que possuem exatamente 6 cilindros, usando @filter().\nSelecionamos apenas as colunas Model, MPG, WT e Eficiencia, usando @select().\nOrdenamos o dataset pelo valor da Eficiencia, em ordem decrescente, usando @arrange() para ordenar e desc() para determinar que era decrescente.\n\n\nObs.: desc() é uma função auxiliar.\n\n\nPor fim, optamos por visualizar apenas da linha 1 até a linha 6 do dataset, utilizando a função @slice().\n\nAgora, vejamos um exemplo de formatação dos dados e utilização das funções de join.\nVamos supor que possuímos dois dataframes: um com informações sobre clientes e outro com compras. Queremos combinar os dados para visualizar o nome dos clientes junto com seus respectivos valores de compra.\n\n\nusing TidierData, DataFrames\n\nclientes = DataFrame(ID = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], Nome = [\"Leonardo\", \"Arthur\", \"Carlos\", \"Esther\", \"Caio\", \"Guilherme\", \"Henrique\", \"Nicole\", \"Pedro\", \"Sarah\"])\n\n10×2 DataFrame\n Row │ ID     Nome\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  Leonardo\n   2 │     2  Arthur\n   3 │     3  Carlos\n   4 │     4  Esther\n   5 │     5  Caio\n   6 │     6  Guilherme\n   7 │     7  Henrique\n   8 │     8  Nicole\n   9 │     9  Pedro\n  10 │    10  Sarah\n\ncompras = DataFrame(ID = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], Valor = [150, 200, 300, 100, 250, 220, 310, 420, 500, 50])\n\n10×2 DataFrame\n Row │ ID     Valor\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1    150\n   2 │     2    200\n   3 │     3    300\n   4 │     4    100\n   5 │     5    250\n   6 │     6    220\n   7 │     7    310\n   8 │     8    420\n   9 │     9    500\n  10 │    10     50\n\n\n@left_join(compras, clientes)\n\n10×3 DataFrame\n Row │ ID     Valor  Nome\n     │ Int64  Int64  String?\n─────┼─────────────────────────\n   1 │     1    150  Leonardo\n   2 │     2    200  Arthur\n   3 │     3    300  Carlos\n   4 │     4    100  Esther\n   5 │     5    250  Caio\n   6 │     6    220  Guilherme\n   7 │     7    310  Henrique\n   8 │     8    420  Nicole\n   9 │     9    500  Pedro\n  10 │    10     50  Sarah\n\n\n\nAqui, usamos a função @left_join() para unir nossos dados através da coluna ID. Assim, obtemos um dataframe alinhado por ID, com as informações dos clientes e o valor de suas respectivas compras.\n\nObserve que o uso da função @left_join() é simples e intuitivo, pois ela une os dois dataframes automaticamente pela coluna em comum, sem necessidade de especificação explícita.\n\n\n\nusing TidierData, DataFrames\n\ndf = DataFrame(Nome = [\"Thiago\", \"Vitor\", \"Gabriel\", \"Ana\", \"Gustavo\", \"Leticia\"], Nota1 = [8, 7, 7.5, 6, 9, 10], Nota2 = [9, 10, 4, 5.5, 5, 9])\n\n6×3 DataFrame\n Row │ Nome     Nota1    Nota2\n     │ String   Float64  Float64\n─────┼───────────────────────────\n   1 │ Thiago       8.0      9.0\n   2 │ Vitor        7.0     10.0\n   3 │ Gabriel      7.5      4.0\n   4 │ Ana          6.0      5.5\n   5 │ Gustavo      9.0      5.0\n   6 │ Leticia     10.0      9.0\n\n\nprint(df)\n\n6×3 DataFrame\n Row │ Nome     Nota1    Nota2\n     │ String   Float64  Float64\n─────┼───────────────────────────\n   1 │ Thiago       8.0      9.0\n   2 │ Vitor        7.0     10.0\n   3 │ Gabriel      7.5      4.0\n   4 │ Ana          6.0      5.5\n   5 │ Gustavo      9.0      5.0\n   6 │ Leticia     10.0      9.0\n\n\n@chain df begin\n    @pivot_longer(cols = [:Nota1, :Nota2], names_to = :Avaliação, values_to = :Nota)\nend\n\n12×3 DataFrame\n Row │ Nome     Avaliação  Nota\n     │ String   String     Float64\n─────┼─────────────────────────────\n   1 │ Thiago   Nota1          8.0\n   2 │ Vitor    Nota1          7.0\n   3 │ Gabriel  Nota1          7.5\n   4 │ Ana      Nota1          6.0\n   5 │ Gustavo  Nota1          9.0\n   6 │ Leticia  Nota1         10.0\n   7 │ Thiago   Nota2          9.0\n   8 │ Vitor    Nota2         10.0\n   9 │ Gabriel  Nota2          4.0\n  10 │ Ana      Nota2          5.5\n  11 │ Gustavo  Nota2          5.0\n  12 │ Leticia  Nota2          9.0\n\n\n\nAqui, transformamos o dataframe do formato wide para long usando a função @pivot_longer(). A mesma lógica se aplica caso queiramos converter de long para wide, utilizando a função @pivot_wider()."
  },
  {
    "objectID": "Blog/tidierdata.html#funções-auxiliares",
    "href": "Blog/tidierdata.html#funções-auxiliares",
    "title": "Introdução ao pacote TidierData.jl",
    "section": "Funções auxiliares",
    "text": "Funções auxiliares\n\nAlém das macros principais como @mutate, @filter e @summarize, o TidierData.jl oferece funções auxiliares que tornam seu código mais expressivo, claro e eficiente. Vamos explorar algumas delas com exemplos práticos:\n\n\nif_else()\n\nLógica condicional simples e vetorizada:\n\n\nusing TidierData, DataFrames\n\nvalores = DataFrame(Nome = [\"A\", \"B\", \"C\"], Salario = [3000, 5000, 4000])\n\n3×2 DataFrame\n Row │ Nome    Salario\n     │ String  Int64\n─────┼─────────────────\n   1 │ A          3000\n   2 │ B          5000\n   3 │ C          4000\n\n\n@chain valores begin\n    @mutate(Status = if_else(`Salario` .&gt; 4000, \"Alto\", \"Médio ou Baixo\"))\nend\n\n3×3 DataFrame\n Row │ Nome    Salario  Status\n     │ String  Int64    String\n─────┼─────────────────────────────────\n   1 │ A          3000  Médio ou Baixo\n   2 │ B          5000  Alto\n   3 │ C          4000  Médio ou Baixo\n\n\n\n\ncase_when()\n\nPara múltiplas condições, substituindo vários if_else():\n\n\nusing TidierData, DataFrames\n\ndf2 = DataFrame(Nota = [10, 2, 6, 4, 7.1, 4.9, 9.7])\n\n7×1 DataFrame\n Row │ Nota\n     │ Float64\n─────┼─────────\n   1 │    10.0\n   2 │     2.0\n   3 │     6.0\n   4 │     4.0\n   5 │     7.1\n   6 │     4.9\n   7 │     9.7\n\n\n@chain df2 begin\n    @mutate(Conceito = case_when(\n        `Nota` .&gt;= 9 =&gt; \"A\",\n        `Nota` .&gt;= 7 =&gt; \"B\",\n        `Nota` .&gt;= 5 =&gt; \"C\",\n        true        =&gt; \"D\"\n    ))\nend\n\n7×2 DataFrame\n Row │ Nota     Conceito\n     │ Float64  String\n─────┼───────────────────\n   1 │    10.0  A\n   2 │     2.0  D\n   3 │     6.0  C\n   4 │     4.0  D\n   5 │     7.1  B\n   6 │     4.9  D\n   7 │     9.7  A\n\n\n\n\nstarts_with(), ends_with()\n\nSelecionando colunas com nomes que seguem um padrão:\n\n\nusing TidierData, DataFrames\n\ndf3 = DataFrame(\n    Nome = [\"José\", \"Carla\", \"Humberto\"],\n    Nota1 = [7, 9, 8],\n    Nota2 = [8, 10, 10],\n    Idade = [20, 22, 24]\n)\n\n3×4 DataFrame\n Row │ Nome      Nota1  Nota2  Idade\n     │ String    Int64  Int64  Int64\n─────┼───────────────────────────────\n   1 │ José          7      8     20\n   2 │ Carla         9     10     22\n   3 │ Humberto      8     10     24\n\n\ncomeca = @chain df3 begin\n    @select(`Nome`, starts_with(\"Nota\"))\nend\n\n3×3 DataFrame\n Row │ Nome      Nota1  Nota2\n     │ String    Int64  Int64\n─────┼────────────────────────\n   1 │ José          7      8\n   2 │ Carla         9     10\n   3 │ Humberto      8     10\n\n\ntermina = @chain df3 begin\n  @select(`Nome`, ends_with(\"ade\"))\nend\n\n3×2 DataFrame\n Row │ Nome      Idade\n     │ String    Int64\n─────┼─────────────────\n   1 │ José         20\n   2 │ Carla        22\n   3 │ Humberto     24\n\n\n\n\nObs.: As funções endswith() da base do julia e ends_with() do pacote TidierData.jl tem uma pequena diferença: a função ends_with() é usada para nomes de colunas, enquanto endswith() é usada para valores dentro das colunas."
  },
  {
    "objectID": "Blog/pacotes_estatistica.html",
    "href": "Blog/pacotes_estatistica.html",
    "title": "Pacotes Essenciais para Trabalhar com Estatística em Julia",
    "section": "",
    "text": "Ao falar de Estatística, a primeira linguagem de programação que costuma vir à mente é R. Criada especificamente para análise estatística e ciência de dados, oferece uma ampla gama de ferramentas estatísticas já disponíveis por padrão, além de milhares de pacotes criados para os mais diversos propósitos.\nPara nossa sorte, embora a linguagem Julia não tenha sido projetada exclusivamente para a Estatística, já conta com grande parte das ferramentas essenciais, graças a um ecossistema de pacotes que cresce rapidamente e abrange diversas áreas da análise de dados, da modelagem estatística e do aprendizado de máquina.\nVamos, então, conhecer os principais pacotes para trabalhar com Estatística em Julia, organizados por área de aplicação (desde tarefas básicas até análises mais complexas)."
  },
  {
    "objectID": "Blog/pacotes_estatistica.html#introdução",
    "href": "Blog/pacotes_estatistica.html#introdução",
    "title": "Pacotes Essenciais para Trabalhar com Estatística em Julia",
    "section": "",
    "text": "Ao falar de Estatística, a primeira linguagem de programação que costuma vir à mente é R. Criada especificamente para análise estatística e ciência de dados, oferece uma ampla gama de ferramentas estatísticas já disponíveis por padrão, além de milhares de pacotes criados para os mais diversos propósitos.\nPara nossa sorte, embora a linguagem Julia não tenha sido projetada exclusivamente para a Estatística, já conta com grande parte das ferramentas essenciais, graças a um ecossistema de pacotes que cresce rapidamente e abrange diversas áreas da análise de dados, da modelagem estatística e do aprendizado de máquina.\nVamos, então, conhecer os principais pacotes para trabalhar com Estatística em Julia, organizados por área de aplicação (desde tarefas básicas até análises mais complexas)."
  },
  {
    "objectID": "Blog/pacotes_estatistica.html#manipulação-de-dados-e-estatísticas-sumárias",
    "href": "Blog/pacotes_estatistica.html#manipulação-de-dados-e-estatísticas-sumárias",
    "title": "Pacotes Essenciais para Trabalhar com Estatística em Julia",
    "section": "Manipulação de Dados e Estatísticas Sumárias",
    "text": "Manipulação de Dados e Estatísticas Sumárias\n\nStatsBase: Ferramentas básicas de estatística descritiva;\nFreqTables: Construção de tabelas de frequências para análise exploratória;\nDataFrames: Importação e manipulação de bases de dados tabulares."
  },
  {
    "objectID": "Blog/pacotes_estatistica.html#variáveis-aleatórias",
    "href": "Blog/pacotes_estatistica.html#variáveis-aleatórias",
    "title": "Pacotes Essenciais para Trabalhar com Estatística em Julia",
    "section": "Variáveis Aleatórias",
    "text": "Variáveis Aleatórias\n\nDistributions: Definição, manipulação e amostragem de distribuições de probabilidade;\nRandom: Geração de números aleatórios com uso de sementes, garantindo a reprodutibilidade."
  },
  {
    "objectID": "Blog/pacotes_estatistica.html#visualização-de-dados",
    "href": "Blog/pacotes_estatistica.html#visualização-de-dados",
    "title": "Pacotes Essenciais para Trabalhar com Estatística em Julia",
    "section": "Visualização de Dados",
    "text": "Visualização de Dados\n\nPlots: Construção de uma ampla variedade de gráficos;\nGadfly: Criação de gráficos com sintaxe semelhante à do pacote ggplot2, do R."
  },
  {
    "objectID": "Blog/pacotes_estatistica.html#modelagem-e-testes-de-hipótese",
    "href": "Blog/pacotes_estatistica.html#modelagem-e-testes-de-hipótese",
    "title": "Pacotes Essenciais para Trabalhar com Estatística em Julia",
    "section": "Modelagem e Testes de Hipótese",
    "text": "Modelagem e Testes de Hipótese\n\nHypotesisTests: Realização de testes de hipótese frequentistas, incluindo testes paramétricos e não paramétricos;\nGLM: Modelagens de regressões lineares e regressões lineares generalizadas;\nMixedModels: Ajuste de modelos lineares e generalizados com efeitos mistos;\nOptim: Otimização de funções, essencial para maximizar verossimilhanças;\nMultivariateStats: Ferramentas de análise multivariada, como PCA e LDA;\nTimeSeries: Manipulação, visualização e modelagem de séries temporais."
  },
  {
    "objectID": "Blog/pacotes_estatistica.html#inferência-bayesiana",
    "href": "Blog/pacotes_estatistica.html#inferência-bayesiana",
    "title": "Pacotes Essenciais para Trabalhar com Estatística em Julia",
    "section": "Inferência Bayesiana",
    "text": "Inferência Bayesiana\n\nTuring: Modelagem estatística bayesiana baseada em amostragem;\nMCMCChains: Ferramentas para diagnóstico, resumo e visualização de cadeias de Markov geradas por MCMC."
  },
  {
    "objectID": "Blog/pacotes_estatistica.html#aprendizado-de-máquina",
    "href": "Blog/pacotes_estatistica.html#aprendizado-de-máquina",
    "title": "Pacotes Essenciais para Trabalhar com Estatística em Julia",
    "section": "Aprendizado de Máquina",
    "text": "Aprendizado de Máquina\n\nDecisionTree: Algoritmos de árvores de decisão, árvores de regressão e florestas aleatórias;\nClustering: Algoritmos de clusterização, voltados para aprendizado de máquina não supervisionado;\nScikitLearn: Diversos algoritmos de machine learning com sintaxe semelhante à da biblioteca do Python, de mesmo nome;\nMLBase: Ferramentas auxiliares para aplicação de modelos de machine learning.\n\n\nAté aqui, temos apresentados apenas alguns exemplos de pacotes que podem ser utilizados em Julia, mas existem muitos outros!. Para explorar mais, acesse o site Julia Packages e descubra todo o potencial que Julia pode lhe oferecer."
  },
  {
    "objectID": "Blog/pacotes_estatistica.html#conclusão",
    "href": "Blog/pacotes_estatistica.html#conclusão",
    "title": "Pacotes Essenciais para Trabalhar com Estatística em Julia",
    "section": "Conclusão",
    "text": "Conclusão\n\nCom esse conjunto de pacotes, Julia se consolida como uma linguagem útil para análise de dados, modelagem estatística/econometrica e aprendizado de máquina. Embora seu uso ainda esteja em crescimento, já é possível realizar diversas análises envolvendo dados (desde análises descritivas simples até modelagens complexas).\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/as-origens.html",
    "href": "Blog/as-origens.html",
    "title": "Do Zero ao Julia: As origens",
    "section": "",
    "text": "A primeira vez que ouvi falar da linguagem Julia foi em 2014, quando ainda era estudante de doutorado no IMECC e buscava formas mais rápidas de executar as simulações da minha pesquisa, que já exigia computação intensiva (Bootstrap). Naquela época, pouquíssimas pessoas trabalhavam com Julia, mas as promessas de desempenho comparável ao de linguagens de baixo nível como C++ ou Fortran rapidamente chamaram minha atenção.\nAlguns meses depois, conversando com colegas da Estatística e da Matemática Aplicada, percebi que não era o único interessado. Isso me motivou a criar um Meetup (alias, estamos reativando ele, então inscriva-se para não perder as novidades). No entanto, com a correria do dia a dia, nunca conseguimos realizar um encontro. Por anos, o grupo ficou lá, crescendo aos poucos, mesmo sem atividades — cheguei a pensar em encerrá-lo, mas no fundo sempre mantive a esperança de um dia retomar essa ideia."
  },
  {
    "objectID": "Blog/as-origens.html#o-início",
    "href": "Blog/as-origens.html#o-início",
    "title": "Do Zero ao Julia: As origens",
    "section": "",
    "text": "A primeira vez que ouvi falar da linguagem Julia foi em 2014, quando ainda era estudante de doutorado no IMECC e buscava formas mais rápidas de executar as simulações da minha pesquisa, que já exigia computação intensiva (Bootstrap). Naquela época, pouquíssimas pessoas trabalhavam com Julia, mas as promessas de desempenho comparável ao de linguagens de baixo nível como C++ ou Fortran rapidamente chamaram minha atenção.\nAlguns meses depois, conversando com colegas da Estatística e da Matemática Aplicada, percebi que não era o único interessado. Isso me motivou a criar um Meetup (alias, estamos reativando ele, então inscriva-se para não perder as novidades). No entanto, com a correria do dia a dia, nunca conseguimos realizar um encontro. Por anos, o grupo ficou lá, crescendo aos poucos, mesmo sem atividades — cheguei a pensar em encerrá-lo, mas no fundo sempre mantive a esperança de um dia retomar essa ideia."
  },
  {
    "objectID": "Blog/as-origens.html#o-transcurso",
    "href": "Blog/as-origens.html#o-transcurso",
    "title": "Do Zero ao Julia: As origens",
    "section": "O transcurso",
    "text": "O transcurso\n\nApós o doutorado, acabei focando em outras prioridades — publicar artigos, trabalhar na indústria, estudar para concursos, preparar aulas… Ainda assim, a vontade de usar Julia permanecia. Com o tempo, fui explorando outras particularidades da linguagem: a possibilidade de escrever símbolos matemáticos diretamente no código (o que facilita absurdamente a implementação de novos métodos propostos na literatura), a programação nativa em paralelo e distribuída, e o fato de Julia resolver o famoso problema das duas linuagens.\nMotivado pelas vantagens da linguagem, quando entrei na UNICAMP como docente resolvi incluir Julia como linguagem a ser utilizada em umas das disciplinas: Econometria. Posteriormente, trabalhando num artigo com alguns colegas (Hotta et al. 2025), resolvi implementar tudo em Julia, do zero, o que acabou sendo um ótima e desafiadora experiência."
  },
  {
    "objectID": "Blog/as-origens.html#a-idealização",
    "href": "Blog/as-origens.html#a-idealização",
    "title": "Do Zero ao Julia: As origens",
    "section": "A idealização",
    "text": "A idealização\n\nApós a curta experiência mão na massa com Julia, entender a importância da extensão e de ver a necessidade dos alunos por se envolverem em atividade de extensão, resolvi unir o útil ao agradável e foi assim que surgiu a primeira ideia do projeto. Ainda no rascunho, perguntei aos meus orientandos o que eles achavam da ideia e alguns deles toparam participar desde o início (alias, foram eles que me ajudaram a escolher o nome). Passaram-se alguns meses e agora com a ideia mais amadurecida, escrevi uma proposta e a submeti à comissão de extensão do IMECC e, após algunas sugestões da comissão, o projeto foi aprovado e lançado oficialmente na sua forma atual.\n\n\n\n\n\nConfesso que, inicialmente, achei que apenas meus orientandos se interessariam. Mas, para minha grata surpresa, o projeto teve uma ótima recepção. Hoje, temos mais de 20 pessoas envolvidas, colaborando com as redes sociais, escrevendo posts, tutoriais, organizando minicursos e cuidando da parte editorial, entre outras atividades que loog logo ficarão sabendo."
  },
  {
    "objectID": "Blog/as-origens.html#a-meta",
    "href": "Blog/as-origens.html#a-meta",
    "title": "Do Zero ao Julia: As origens",
    "section": "A meta",
    "text": "A meta\n\nMinha esperança é que o site www.ime.unicamp.br/julialang se torne um ponto de referência para quem quer aprender e explorar a linguagem Julia — oferecendo desde dicas para iniciantes até tutoriais completos e atualizações sobre a linguagem. Mais do que isso, torço para que o projeto ajude os alunos a desenvolverem habilidades valiosas para o mercado e, ao mesmo tempo, inspire a comunidade acadêmica e de ciência de dados a enxergar Julia como um verdadeiro mar de possibilidades.\nEstou longe de ser um expert em Julia, mas espero que em breve tanto você quanto eu saibamos um pouco mais dessa linguagem.\nHappy coding!\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto, bem como para a geração de imagens."
  },
  {
    "objectID": "Blog/instalar_julia.html",
    "href": "Blog/instalar_julia.html",
    "title": "Como instalar Julia?",
    "section": "",
    "text": "Há muitas vantagens em usar plataformas integradas para desenvolver seus projetos nas mais diversas linguagens de programação. Mas e se sua internet cair? E se você quiser continuar seu projeto de um lugar com conexão lenta? Ter Julia instalado no seu computador resolve esse problema!\nNeste post, aprenderemos algumas formas de instalar Julia no seu computador."
  },
  {
    "objectID": "Blog/instalar_julia.html#introdução",
    "href": "Blog/instalar_julia.html#introdução",
    "title": "Como instalar Julia?",
    "section": "",
    "text": "Há muitas vantagens em usar plataformas integradas para desenvolver seus projetos nas mais diversas linguagens de programação. Mas e se sua internet cair? E se você quiser continuar seu projeto de um lugar com conexão lenta? Ter Julia instalado no seu computador resolve esse problema!\nNeste post, aprenderemos algumas formas de instalar Julia no seu computador."
  },
  {
    "objectID": "Blog/instalar_julia.html#pelo-site-oficial",
    "href": "Blog/instalar_julia.html#pelo-site-oficial",
    "title": "Como instalar Julia?",
    "section": "Pelo site oficial",
    "text": "Pelo site oficial\nClicando em Julia, você será redirecionado para o site oficial de Julia, onde poderá realizar a instalação manual da versão mais recente de Julia apenas baixando um instalador compatível com seu sistema operacional (.exe, .dmg, etc). É importante escolher um instalador compatível com o seu sistema operacional, caso contrário não será possível a instalação.\nCertifique-se de ter pelo menos 0,98 GB livres para armazenar os arquivos em seu computador. Após o término do download, siga as instruções recomendadas de configuração do instalador oficial (clicando em “Próximo” em todas as abas, para o caso da instalação padrao) e aguarde enquanto Julia é instalado.\n\n\n\nAtalho no Desktop\n\n\n\nCriar um atalho na área de trabalho facilitará muito o acesso ao aplicativo no dia a dia, embora essa seleção seja opcional.\n\nUma vez instalado Julia no seu computador, você poderá programar diretamente no terminal de Julia, que deve se parecer com a seguinte imagem:\n\n\n\nTerminal Julia"
  },
  {
    "objectID": "Blog/instalar_julia.html#outros-caminhos",
    "href": "Blog/instalar_julia.html#outros-caminhos",
    "title": "Como instalar Julia?",
    "section": "Outros caminhos",
    "text": "Outros caminhos\nJulia também está disponível para download pela Microsoft Store. Para os usuários de Linux e macOS, essa opção não se encontra disponível por enquanto, mas também é possível instalar e utilizar Julia diretamente do terminal do computador.\nNo Windows, pressione as teclas Windows + R, digite cmd e pressione “Enter” para abrir o terminal. Em seguida, execute o comando abaixo e digite Y quando solicitado pelo sistema:\nwinget install Julia\nQuando a instalação for concluída, você pode digitar where julia para localizar o caminho até o .exe de Julia, ou simplesmente digitar julia no terminal para obter uma interface semelhante à do aplicativo do programa.\nNo macOS ou Linux, abra o terminal e digite\ncurl -fsSL https://install.julialang.org | sh\nQuando a instalação for concluída, você pode digitar which julia para localizar o caminho até o executável de Julia, ou simplesmente digitar julia no terminal para acessar a interface interativa do programa.\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/Julia no Mercado de Trabalho.html",
    "href": "Blog/Julia no Mercado de Trabalho.html",
    "title": "Julia no Mercado de Trabalho",
    "section": "",
    "text": "Você, seja estudante, profissional formado ou simplesmente alguém curioso sobre a linguagem Julia, talvez já tenha se perguntado: qual é a relação entre Julia e o mercado de trabalho? Será que ela é amplamente usada? É mais eficiente que outras linguagens? Quais são suas principais diferenças e, não menos importante, por que uma empresa optaria (ou não) por adotá-la em seus projetos?\nNeste blog, vou abordar todas essas questões e ajudar você a entender melhor o papel da Julia no mundo profissional. Então, vem comigo e segue o fio!"
  },
  {
    "objectID": "Blog/Julia no Mercado de Trabalho.html#uso-de-julia-no-mercado-de-trabalho",
    "href": "Blog/Julia no Mercado de Trabalho.html#uso-de-julia-no-mercado-de-trabalho",
    "title": "Julia no Mercado de Trabalho",
    "section": "Uso de Julia no mercado de trabalho",
    "text": "Uso de Julia no mercado de trabalho\nSabemos que Julia ainda não é tão popular quanto outras linguagens como Python, R ou Java. Isso, pode levarmos a pensar que, talvez, Julia é apenas utilizada no meio acadêmico, mas, não se engane: Julia já está mais presente no mercado de trabalho do que você imagina!\nPor ser uma linguagem de alto nível, projetada especialmente para cálculos científicos e computacionais de grande porte e alta complexidade, algumas empresas fazem questão de incluí-la em seu portfólio tecnológico.\nQuer alguns exemplos? Aqui embaixo deixo uma lista de algumas empresas/instituições do mercado que você com certeza conhece e, acredite ou não, elas utilizam bastante da linguagem Julia no seu cotidiano!\n\nGoogle: a linguagem Julia roda em seus TPU’s (chips feitos especificamente para fins de Machine Learning) devido à um projeto chamado “XLA.jl”. Por conta disso, os desenvolvedores da Google podem escrever rápidos códigos de machine learning que rodam dentro do hardware da própria Google, sem a necessidade de alternar entre linguagens.\nNASA: pense bem, você precisa de uma linguagem que modele diversas questões físicas como a gravidade entre planetas, rotas para satélites e espaçonaves, simular órbitas… e você precisa que todos estes cálculos extremamente complexos sejam feitos rápidos e com precisão. Qual linguagem, que é rápida como C++ ou Fortran, mas que é fácil de escrever e de alterar, você utilizaria? Julia, claro! Além disso, por meio do pacote Oceananigans.jl, a NASA simula o comportamento físico dos oceanos com alta precisão e velocidade.\nPfizer: por meio de modelos farmacêuticos, a Pfizer consegue acelerar simulações que antes demoravam dias, até semanas; simular metabolismo e absorção de substâncias no organismo, entre muitos outros. É por meio da plataforma Pumas.jl que a empresa consegue fazer todas as simulações que permitem rápidas tomadas de decisões à respeito de seus experimentos.\nIBM: a linguagem é muito útil para a IBM dado que tratam muito de séries temporais, IA e machine learning, logo, se torna necessário o uso de uma linguagem que facilite a criação de pipelines para esses processos, e Julia faz justamente isso. Automatizações de fluxo de trabalho de machine learning, especialmente quando os dados variam com o tempo é algo feito pela linguagem, especialmente pelas plataformas produzidas pela empresa, como o TSLM.jl e o AutoMLPipeline.jl.\nRenault: a linguagem Julia foi utilizada para resolver um problema logístico: planejar rotas e estoques em toda a Europa para recolher embalagens reutilizáveis. Via métodos tradicionais, as soluções eram lentas e ineficazes, então a empresa implementou um algoritmo em Julia que otimizou todo o processo e reduziu custos logísticos.\n\nAlguma dessas empresas te surpreendeu? Você pode encontrar mais empresas que utilizam a linguagem e também casos de estudos em que aplicaram Julia no seguinte link: https://info.juliahub.com/industries/case-studies\n\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica, aprimoramento do texto e criação de imagens."
  },
  {
    "objectID": "Blog/Julia no Mercado de Trabalho.html#referências",
    "href": "Blog/Julia no Mercado de Trabalho.html#referências",
    "title": "Julia no Mercado de Trabalho",
    "section": "Referências",
    "text": "Referências\n\nNasa: Julia Programming Language Benchmark Using a Flight Simulation; Here’s how NASA is using Julia to better understand the ocean\nGoogle: Google Cloud TPUs Now Speak Julia\nRenault: Solving a Continent-Scale Inventory Routing Problem at Renault\nPfizer: Pfizer uses Julia to accelerate simulations of new therapies for metabolic diseases up to 175x;\nIBM: Designing Machine Learning Pipeline Toolkit for AutoML Surrogate Modeling Optimization"
  },
  {
    "objectID": "Blog/Zero ao Julia - Entrevistas.html",
    "href": "Blog/Zero ao Julia - Entrevistas.html",
    "title": "Entrevistas - Abel Soares Siqueira e Paulo José da Silva e Silva",
    "section": "",
    "text": "Você já se perguntou como profissionais usam Julia no dia a dia? Nosso time conversou com Paulo José da Silva e Silva, professor do Departamento de Matemática Aplicada da UNICAMP, e com Abel Soares Siqueira, Doutor em Matemática Aplicada e Research Software Engineer no The Netherlands eScience, para conhecer suas experiências, rotinas e dicas sobre a linguagem. Confira o que eles compartilharam!"
  },
  {
    "objectID": "Blog/Zero ao Julia - Entrevistas.html#entrevistados",
    "href": "Blog/Zero ao Julia - Entrevistas.html#entrevistados",
    "title": "Entrevistas - Abel Soares Siqueira e Paulo José da Silva e Silva",
    "section": "Entrevistados",
    "text": "Entrevistados\n\n\n\n\n\n\n\n\n\n\n\n(a) Abel Soares Siqueira\n\n\n\n\n\n\n\n\n\n\n\n(b) Paulo José da Silva e Silva\n\n\n\n\n\n\n\nFigura 1: Entrevistados\n\n\n\n\nAbel Soares Siqueira: Formou-se em Matemática Aplicada na UNICAMP e seguiu para o doutorado na mesma universidade, obtendo o título de doutor em 2013. Foi professor na UFPR entre 2014 e 2021. Durante sua rotina acadêmica, utilizava Matlab, C++ e alguns pacotes em Fortran. Em 2015, conheceu Julia por sugestão de um amigo e vem usando a linguagem desde então. Atualmente, atua como Engenheiro de Software nos Países Baixos (Holanda).\nProf. Paulo José da Silva e Silva: Formou-se em Ciência da Computação pelo IME-USP e tem mestrado e doutorado em Matemática Aplicada pela mesma instituição. Foi professor da USP de 2001 a 2012 e, em 2012, transferiu-se para o Departamento de Matemática Aplicada da UNICAMP, onde atualmente é professor titular. Trabalha com otimização contínua, focando em seus aspectos teóricos e computacionais e na interface com áreas de aplicação, como ciência de dados."
  },
  {
    "objectID": "Blog/Zero ao Julia - Entrevistas.html#perguntas-e-respostas",
    "href": "Blog/Zero ao Julia - Entrevistas.html#perguntas-e-respostas",
    "title": "Entrevistas - Abel Soares Siqueira e Paulo José da Silva e Silva",
    "section": "Perguntas e Respostas",
    "text": "Perguntas e Respostas\n\nPergunta 1: Você se lembra de como foi seu primeiro contato com Julia?\n\nAbel: No início, achei uma linguagem bem tranquila e rápida, com uma sintaxe parecida com Matlab. Uma questão que considero importante hoje, pensando no meu primeiro contato, é sobre a “responsabilidade” que criei no que faço em Julia — os produtos finais que entrego, reprodutibilidade, entre outros.\nPaulo: Comprei um livro chamado Seven More Languages in Seven Weeks e uma das linguagens de programação ensinadas no livro era Julia. Na época, não aprendi a linguagem tão profundamente, até que notei que em otimização numérica, minha área de pesquisa, Julia era muito eficaz. Desde então, me aprofundei nela.\n\n\n\nPergunta 2: O que te motivou a começar a utilizar Julia em vez de outras linguagens?\n\nAbel: Considero Julia muito mais fácil de utilizar do que outras linguagens. Ela entrega exatamente o que preciso e é uma linguagem muito boa para isso. Por ser de alto nível, ela permite que questões de matemática avançada possam ser implementadas facilmente em comparação a outras linguagens de programação.\nPaulo: Julia possui uma série de características interessantes para quem faz computação científica: linguagem dinâmica, inferência e geração de códigos rápidos compilados, diferenciação automática (otimização contínua) e uma sintaxe interessante para matemática — como um operador “bolinha” (\\(\\circ\\)). para tratar de funções compostas e uma facilidade na leitura de números (1 bilhão = 1_000_000_000 em Julia).\n\n\n\nPergunta 3: Como você costuma utilizar Julia no seu dia a dia?\n\nAbel: Em meu trabalho, utilizo Julia para fins de criação de softwares de pesquisa, assim como garanto que esse software seja sustentável para outras pessoas/usuários (como falei, a reprodutibilidade é muito importante).\nPaulo: Como professor da UNICAMP, utilizo linguagens para lecionar matérias, como Cálculo Numérico, em que já fiz notas de aula utilizando Julia. Além disso, criei uma nova disciplina obrigatória no curso de Matemática Aplicada da UNICAMP, chamada de Laboratório da Computação Científica. Ela está focada em aumentar a proficiência dos alunos em programação no contexto da área. Todo o material que uso na disciplina está escrito em cadernos Pluto em Julia e foi adaptado do curso Introduction to Computational Thinking, do MIT, com autorização dos autores. Também já criei e estou criando atualmente um pacote em Julia que trata de escrever e desenvolver modelos não lineares.\n\n\n\nPergunta 4: Se tivesse que parar de usar Julia hoje, como isso impactaria sua rotina?\n\nAbel: Eu saberia fazer o que preciso fazer fora de Julia, pois antes programava em C, C++ e, especialmente, Python. Entretanto, Julia unifica todo o processo da minha rotina, então é ideal para o que faço.\nPaulo: A linguagem Julia acaba unificando meu trabalho, dado a minha área de pesquisa, devido à sua interface, pacotes existentes, sua compilação, entre outros. Embora Python seja também uma linguagem dinâmica, ele não possui uma boa biblioteca de diferenciação automática. Então, eu precisaria migrar entre diferentes linguagens/ambientes de trabalho para tratar de um único problema.\n\n\n\nPergunta 5: Quais principais diferenças/dificuldades/facilidades você vê entre Julia e outras linguagens de programação?\n\nAbel: Uma facilidade é que Julia, na primeira vez que você roda o código, compila e depois roda o código. Nas seguintes vezes que você rodar o mesmo código, ele já roda todo o código sem nenhuma espera. Além disso, você pode entender o código como lógica matemática e também conectar diferentes pacotes. Uma desvantagem é o startup time do código, ou o TTFX (Time to First Execution).\nPaulo: De maneira geral, Julia resolve bem os problemas que tenho, devido às suas muitas características. Se escrevesse um protótipo de código em Python, precisaria reescrevê-lo em C++, por exemplo, para deixá-lo mais eficiente/veloz. Se preciso de uma linguagem específica, compilada e também dinâmica para processamento, Julia faz essas duas partes muito bem. Entretanto, considero que Python é mais fácil de ler/entender do que Julia, por ter códigos mais claros. Não quero dizer, entretanto, que exista uma linguagem unificada, melhor que todas as outras; apenas que Julia é a linguagem que mais se adequa à minha rotina e problemas computacionais. A seleção de linguagem utilizada depende do problema a ser solucionado (otimização, análise de dados, machine learning, etc.).\n\n\n\nPergunta 6: Você acredita que o ensino de Julia deveria ser mais incentivado no mercado trabalho ou no meio acadêmico?\n\nAbel: Na faculdade, há fáceis razões de utilizar Julia, como em Cálculo Numérico e Álgebra Linear, pois é fácil de escrever as expressões matemáticas e os algoritmos iterativos. No mercado, entretanto, o uso de Julia é mais focado em pesquisas que envolvem matemática avançada, então é um nicho mais específico. Acredito e espero que Julia tome o lugar do Matlab, principalmente no meio acadêmico. Existe também uma possibilidade de que Julia assuma o lugar de principal linguagem para Data Science. Mas não tão cedo, pois Julia não tem os pacotes necessários para que os profissionais sintam a necessidade de fazer essa migração de linguagens.\nPaulo: Se a sua área envolve otimização, diferenciação e outros temas relacionados, é imprescindível saber sobre Julia. Além disso, acredito que, no meio acadêmico, Julia poderia, em um futuro próximo, substituir ou se juntar ao Matlab ou Python como linguagem ensinada a graduandos/as por ser melhor em algumas questões. Também vejo muitos cursos/materiais em que Julia poderia ser incluída, mas por “inércia”, linguagens como Matlab ou Python são utilizadas.\n\n\n\nPergunta 7: Que conselhos você daria a quem está pensando em aprender ou começar a utilizar Julia?\n\nAbel: Recomendo dar uma olhada no meu canal do YouTube, em que falo sobre minha área e aplicações. Além disso, a maneira mais fácil de não desanimar enquanto aprende Julia, ou qualquer outra linguagem, é procurar um projeto prático fácil — seja disciplinas, matérias, cursos, entre outros — para que você não foque somente na teoria. Recomendo também as seguintes referências: Pense em Julia (livro) e github.com/JuliaLang (comunidade).\n\nPense em Julia está disponível de forma gratuita no Github ou pode ser encomendado pela Amazon.\n\nPaulo: Não aprenda Julia apenas para resolver um problema específico que você tem interesse. Se for para aprender Julia, ou qualquer outra linguagem, aprenda com calma: leia materiais, documentações e artigos, e procure entender aquela linguagem o mais profundamente possível — especialmente num caso em que você pode precisar utilizar aquela linguagem mais vezes. Assim, você realmente aprende aquela linguagem e o que você está fazendo com ela. Um exemplo bom é o LaTeX: muitos alunos da área de exatas acabam precisando utilizar LaTeX para produzir relatórios durante sua graduação ou até uma pós-graduação, entretanto, é preferível aprender a linguagem quando você percebe que fará parte da sua rotina do que escrever nessa linguagem apenas baseado na necessidade. Pois em alguns anos, quando você precisar fazer um relatório, você vai saber muito bem como escrevê-lo.\n\n\n\nPergunta 8: Você é desenvolvedor de um pacote de Julia, certo? Pode nos contar mais um pouco sobre?\n\nAbel: Desde que comecei a usar Julia, trabalhei com vários pacotes de otimização e álgebra linear, além de criar um site que auxilia na criação de pacotes do zero. Vejo que a criação de pacotes em Julia não é complicada, pois existem até pacotes que te ajudam a criar outros pacotes — além de possuir uma maior padronização nos pacotes dependendo do problema a ser resolvido. Em outras linguagens, um único problema pode ser resolvido por diferentes pacotes existentes.\nPaulo: Criar um pacote em Julia é muito fácil. Você precisa de um repositório em sua máquina e seguir convenções para criação de pacotes na linguagem. Se isso está feito, basta “avisar” à linguagem que aquilo que está ali é um pacote, e pronto. A divulgação desse pacote também é bem facilitada. Basta fazer, por exemplo, um commit no GitHub, que o pacote é testado, atualizado e disponibilizado de forma pública, caso prefira. Em geral, Julia é bem estruturada para criação de pacotes. Por meio do site oficial de Julia, uma busca de palavras-chave retorna pacotes que se relacionam com aquela palavra/tema. Em meu uso de Julia, criei um pacote chamado NLPModelsAlgencan.JL, uma junção de dois pacotes que faz manipulações não lineares. Estou criando também um pacote para projetar o simplexo que, em suma, é o conjunto de todos os números que somam 1 em uma dimensão N.\n\n\n\nPergunta 9: Quer deixar algum recado para o pessoal da UNICAMP ou do Brasil em geral?\n\nAbel: Aqui nos Países Baixos, existe uma conferência de Julia chamada JuliaCon que já participei. Então, para a comunidade brasileira, recomendo fazerem uma conferência de Julia aí no Brasil, pois pode atrair mais interesse na linguagem no país e também na América Latina, tanto por programadores/cientistas quanto por empresas. Por fim, talvez Julia não seja a melhor linguagem para você, especialmente se for sua primeira linguagem, mas não deixe de estudar sobre ela, pois é uma linguagem muito útil!\nPaulo: Não tenho a intenção de ser um “garoto-propaganda” de Julia. Claro que a defendo e a utilizo como linguagem principal, pois ela se aplica muito bem aos problemas e necessidades que lido na minha rotina. A depender do problema/necessidade que você tem, a “melhor” linguagem que você utilizará pode ser Julia, assim como pode ser qualquer outra. Além de pensar apenas na linguagem em si, pensem também em todo o ecossistema dessa linguagem. Isso inclui os pacotes que a linguagem possui e como eles funcionam, bem como diferentes funções se comunicam. Por exemplo, para análise de dados, R é uma linguagem bem estruturada, mas não significa que eu não possa fazer computação científica em R caso fosse meu interesse, mas também não significa que R seja a melhor linguagem para tratar desse tema.\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/vscode.html",
    "href": "Blog/vscode.html",
    "title": "Como programar em Julia no Vscode",
    "section": "",
    "text": "A linguagem Julia tem ganhado cada vez mais espaço entre cientistas de dados, estatísticos, economistas, engenheiros e matemáticos. Isto, graças à sua velocidade de processamento e sintaxe simples. Uma das formas mais práticas de programar em Julia é por meio do Visual Studio Code (VS Code), um editor leve, moderno e altamente extensível.\nNeste post, mostraremos como configurar e usar o Julia no VS Code (ideal para quem está começando do zero)."
  },
  {
    "objectID": "Blog/vscode.html#introdução",
    "href": "Blog/vscode.html#introdução",
    "title": "Como programar em Julia no Vscode",
    "section": "",
    "text": "A linguagem Julia tem ganhado cada vez mais espaço entre cientistas de dados, estatísticos, economistas, engenheiros e matemáticos. Isto, graças à sua velocidade de processamento e sintaxe simples. Uma das formas mais práticas de programar em Julia é por meio do Visual Studio Code (VS Code), um editor leve, moderno e altamente extensível.\nNeste post, mostraremos como configurar e usar o Julia no VS Code (ideal para quem está começando do zero)."
  },
  {
    "objectID": "Blog/vscode.html#pré-requisitos",
    "href": "Blog/vscode.html#pré-requisitos",
    "title": "Como programar em Julia no Vscode",
    "section": "Pré-requisitos",
    "text": "Pré-requisitos\n\nTer o Julia instalado;\nTer o VS Code instalado."
  },
  {
    "objectID": "Blog/vscode.html#instalando-o-vs-code",
    "href": "Blog/vscode.html#instalando-o-vs-code",
    "title": "Como programar em Julia no Vscode",
    "section": "Instalando o VS Code",
    "text": "Instalando o VS Code\nSe ainda não instalou o VS Code, clique no link no tópico anterior para ser direcionado à página de download. Ao chegar lá, baixe o arquivo de acordo com o seu sistema operacional.\nApós baixar o arquivo, deixe marcado as seguintes opções durante a instalação:\n\n\n\nInstalação do VS Code"
  },
  {
    "objectID": "Blog/vscode.html#instalando-a-extensão-do-julia-no-vs-code",
    "href": "Blog/vscode.html#instalando-a-extensão-do-julia-no-vs-code",
    "title": "Como programar em Julia no Vscode",
    "section": "Instalando a extensão do Julia no VS Code",
    "text": "Instalando a extensão do Julia no VS Code\nCom o VS Code devidamente instalado, devemos instalar a extensão oficial do Julia. Para isso:\n\nAbra a aba de extensões (Ctrl + shift + X);\nBusque por “Julia”;\nSelecione a extensão e clique em “Install”.\n\n\n\n\nExtensão do Julia"
  },
  {
    "objectID": "Blog/vscode.html#programando-em-julia",
    "href": "Blog/vscode.html#programando-em-julia",
    "title": "Como programar em Julia no Vscode",
    "section": "Programando em Julia",
    "text": "Programando em Julia\nCom a extensão do Julia instalada, chegou a hora de pôr a mão na massa. Para escrever seu primeiro código em Julia no VS Code, crie um novo arquivo do tipo .jl. Para executar determinadas linhas de código, selecione-as e use o atalho Ctrl + Enter. Se preferir, clique no botão “Run”, no canto superior direito, para rodar o arquivo inteiro.\n\n\n\nOlá Mundo!\n\n\nPronto! Agora você já pode começar a programar e desenvolver seus projetos em Julia com o VS Code!\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/HistoriaJulia.html",
    "href": "Blog/HistoriaJulia.html",
    "title": "Entenda a História da Linguagem que une Simplicidade e Desempenho",
    "section": "",
    "text": "Durante muito tempo, programadores sofreram com o problema das duas linguagens, no qual as ideias eram testadas em linguagens mais simples, como R, Python e MATLAB e, à medida que exigiam maior desempenho, precisavam ser reescritas em linguagens mais rápidas, como Fortran ou C++.\nEsse processo, além de trabalhoso, era altamente suscetível a erros e inconsistências no código final. Foi justamente para resolver esse impasse que surgiu a linguagem de programação Julia, com o objetivo de unir desempenho e simplicidade em uma única solução."
  },
  {
    "objectID": "Blog/HistoriaJulia.html#início-de-tudo",
    "href": "Blog/HistoriaJulia.html#início-de-tudo",
    "title": "Entenda a História da Linguagem que une Simplicidade e Desempenho",
    "section": "",
    "text": "Durante muito tempo, programadores sofreram com o problema das duas linguagens, no qual as ideias eram testadas em linguagens mais simples, como R, Python e MATLAB e, à medida que exigiam maior desempenho, precisavam ser reescritas em linguagens mais rápidas, como Fortran ou C++.\nEsse processo, além de trabalhoso, era altamente suscetível a erros e inconsistências no código final. Foi justamente para resolver esse impasse que surgiu a linguagem de programação Julia, com o objetivo de unir desempenho e simplicidade em uma única solução."
  },
  {
    "objectID": "Blog/HistoriaJulia.html#o-desenvolvimento",
    "href": "Blog/HistoriaJulia.html#o-desenvolvimento",
    "title": "Entenda a História da Linguagem que une Simplicidade e Desempenho",
    "section": "O Desenvolvimento",
    "text": "O Desenvolvimento\n\nEm 2009, quatro pesquisadores do MIT (Massachusetts Institute of Technology) começaram a desenvolver uma solução para o problema das duas linguagens. Stefan Karpinski, Alan Edelman, Jeff Bezanson e Viral B. Shah tinham o objetivo de criar uma linguagem de programação moderna, extremamente rápida e, ao mesmo tempo, fácil de escrever.\n![Fonte da imagem: https://news.mit.edu/2018/julia-language-co-creators-win-james-wilkinson-prize-numerical-software-1226\nAo longo de cerca de quatro anos, o projeto foi mantido em sigilo, até que, em fevereiro de 2012, veio a público por meio do artigo “Why We Created Julia”, o qual apresentou ao mundo a primeira versão da linguagem, que já contava com documentação, pacotes básicos e um compilador funcional.\nLogo após seu lançamento, Julia ganhou bastante popularidade no meio científico e ampla divulgação em fóruns e comunidades. Entretanto, o marco da maturidade da ferramenta aconteceu em 2018, com o lançamento da versão 1.0, que trouxe diversas inovações técnicas, como maior confiabilidade para uso em produção, estabilidade da API e consolidação do ecossistema.\n\n\nQuando este post foi escrito, a última versão se Julia é a v1.11.5"
  },
  {
    "objectID": "Blog/HistoriaJulia.html#julia-atualmente",
    "href": "Blog/HistoriaJulia.html#julia-atualmente",
    "title": "Entenda a História da Linguagem que une Simplicidade e Desempenho",
    "section": "Julia atualmente",
    "text": "Julia atualmente\n\n\n\n\n\n\nAtualmente, Julia é utilizado em todo o mundo por cientistas, engenheiros e desenvolvedores que trabalham com dados. Em 2020, ocupava a 47ª posição no índice TIOBE (um termômetro das linguagens mais populares) e, em 2022, já estava na 21ª posição. Isso demonstra que o alcance dessa tecnologia está crescendo constantemente ao longo do tempo.\n\nNo dia que este post foi publicado, Julia estava na posição 33 do índice TIOBE.\n\nJulia surgiu como solução para um problema comum e foi além, tornando-se uma ponte entre o mundo das linguagens mais simples e o das mais rápidas. Seu impacto já é visível em diversas áreas da ciência e do mercado de trabalho, e seu futuro é cada vez mais promissor para quem lida com tecnologia.\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica, aprimoramento do texto e criação de imagens."
  },
  {
    "objectID": "Blog/HistoriaJulia.html#referências",
    "href": "Blog/HistoriaJulia.html#referências",
    "title": "Entenda a História da Linguagem que une Simplicidade e Desempenho",
    "section": "Referências",
    "text": "Referências\n\nO que é Julia?, https://coodesh.com/blog/dicionario/o-que-e-julia/#:~:text=Julia%20%C3%A9%20uma%20linguagem%20de%20programa%C3%A7%C3%A3o%20criada%20pelos%20pesquisadores%20Jeff,Shah%20e%20Alan%20Edelman, acessado em: 2025-05-20.\nJulia (linguagem de programação), https://pt.wikipedia.org/wiki/Julia_(linguagem_de_programa%C3%A7%C3%A3o), acessado em: 2025-05-20.\nThe Julia Programming Language: The History and Uses, https://leftronic.com/blog/julia-programming-language, acessado em: 2025-05-20.\nJulia Data Science, https://juliadatascience.io/pt/julia_accomplish#:~:text=O%20%E2%80%9CProblema%20das%20Duas%20Linguagens%E2%80%9D%20%C3%A9%20bastante%20comum%20na%20computa%C3%A7%C3%A3o,(como%20Python%20ou%20R), acessado em: 2025-05-20."
  },
  {
    "objectID": "Blog/pacotes_datasets.html",
    "href": "Blog/pacotes_datasets.html",
    "title": "Pacotes com Bancos de Dados para trabalhar em Julia",
    "section": "",
    "text": "Ao trabalhar com Estatística e Ciência de Dadps, é fundamental ter conjuntos de dados à disposição, seja para testar funções, praticar análises aprendidas ou realizar simulações com caracteristicas semelhantes às observadas em dados reais. No R, diversos bancos de dados já vêm carregados por padrão ou vem incorporados em diversos pacotes, o que torna o processo bem mais simples. Felizmente, Julia oferece vários pacotes que contêm conjuntos de dados prontos para utilizarmos em nossas análises.\nNeste post, conheceremos alguns dos principais pacotes para acessar diversos bancos de dados úteis em análises estatísticas, econométricas e aprendizado de máquina."
  },
  {
    "objectID": "Blog/pacotes_datasets.html#introdução",
    "href": "Blog/pacotes_datasets.html#introdução",
    "title": "Pacotes com Bancos de Dados para trabalhar em Julia",
    "section": "",
    "text": "Ao trabalhar com Estatística e Ciência de Dadps, é fundamental ter conjuntos de dados à disposição, seja para testar funções, praticar análises aprendidas ou realizar simulações com caracteristicas semelhantes às observadas em dados reais. No R, diversos bancos de dados já vêm carregados por padrão ou vem incorporados em diversos pacotes, o que torna o processo bem mais simples. Felizmente, Julia oferece vários pacotes que contêm conjuntos de dados prontos para utilizarmos em nossas análises.\nNeste post, conheceremos alguns dos principais pacotes para acessar diversos bancos de dados úteis em análises estatísticas, econométricas e aprendizado de máquina."
  },
  {
    "objectID": "Blog/pacotes_datasets.html#instalando-e-carregando-os-pacotes-necessários",
    "href": "Blog/pacotes_datasets.html#instalando-e-carregando-os-pacotes-necessários",
    "title": "Pacotes com Bancos de Dados para trabalhar em Julia",
    "section": "Instalando e Carregando os Pacotes Necessários",
    "text": "Instalando e Carregando os Pacotes Necessários\n\nPrimeiro, vamos instalar e carregar os pacotes que serão utilizados. Para isso, basta executar o código abaixo no seu ambiente:\n\n\n# Instalando os pacotes\nPkg.add([\n    \"DataFrames\",\n    \"RDatasets\",\n    \"MLDatasets\",\n    \"WorldBankData\",\n    \"YFinance\"\n])\n\n# Aceita automaticamente os termos do MLDatasets\nENV[\"DATADEPS_ALWAYS_ACCEPT\"] = \"true\";\n\n# Carregando os pacotes\nusing DataFrames, RDatasets, MLDatasets, WorldBankData, YFinance"
  },
  {
    "objectID": "Blog/pacotes_datasets.html#rdatasets.jl",
    "href": "Blog/pacotes_datasets.html#rdatasets.jl",
    "title": "Pacotes com Bancos de Dados para trabalhar em Julia",
    "section": "RDatasets.jl",
    "text": "RDatasets.jl\n\nO pacote RDatasets.jl faz exatamente o que o nome indica: disponibiliza em Julia os bancos de dados presentes no R e em muitos de seus pacotes. Dessa forma, conjuntos clássicos como iris, mtcars e vários outros ficam prontos para uso no ambiente.\nPara acessá-los, basta utilizar a função dataset:\n\n\niris = dataset(\"datasets\", \"iris\")\n\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     Cat…\n─────┼─────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  setosa\n   2 │         4.9         3.0          1.4         0.2  setosa\n   3 │         4.7         3.2          1.3         0.2  setosa\n   4 │         4.6         3.1          1.5         0.2  setosa\n   5 │         5.0         3.6          1.4         0.2  setosa\n   6 │         5.4         3.9          1.7         0.4  setosa\n   7 │         4.6         3.4          1.4         0.3  setosa\n   8 │         5.0         3.4          1.5         0.2  setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮           ⋮\n 144 │         6.8         3.2          5.9         2.3  virginica\n 145 │         6.7         3.3          5.7         2.5  virginica\n 146 │         6.7         3.0          5.2         2.3  virginica\n 147 │         6.3         2.5          5.0         1.9  virginica\n 148 │         6.5         3.0          5.2         2.0  virginica\n 149 │         6.2         3.4          5.4         2.3  virginica\n 150 │         5.9         3.0          5.1         1.8  virginica\n                                                   135 rows omitted\n\n\n\nmtcars = dataset(\"datasets\", \"mtcars\")\n\n32×12 DataFrame\n Row │ Model              MPG      Cyl    Disp     HP     DRat     WT       QS ⋯\n     │ String31           Float64  Int64  Float64  Int64  Float64  Float64  Fl ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Mazda RX4             21.0      6    160.0    110     3.9     2.62      ⋯\n   2 │ Mazda RX4 Wag         21.0      6    160.0    110     3.9     2.875\n   3 │ Datsun 710            22.8      4    108.0     93     3.85    2.32\n   4 │ Hornet 4 Drive        21.4      6    258.0    110     3.08    3.215\n   5 │ Hornet Sportabout     18.7      8    360.0    175     3.15    3.44      ⋯\n   6 │ Valiant               18.1      6    225.0    105     2.76    3.46\n   7 │ Duster 360            14.3      8    360.0    245     3.21    3.57\n   8 │ Merc 240D             24.4      4    146.7     62     3.69    3.19\n  ⋮  │         ⋮             ⋮       ⋮       ⋮       ⋮       ⋮        ⋮        ⋱\n  26 │ Fiat X1-9             27.3      4     79.0     66     4.08    1.935     ⋯\n  27 │ Porsche 914-2         26.0      4    120.3     91     4.43    2.14\n  28 │ Lotus Europa          30.4      4     95.1    113     3.77    1.513\n  29 │ Ford Pantera L        15.8      8    351.0    264     4.22    3.17\n  30 │ Ferrari Dino          19.7      6    145.0    175     3.62    2.77      ⋯\n  31 │ Maserati Bora         15.0      8    301.0    335     3.54    3.57\n  32 │ Volvo 142E            21.4      4    121.0    109     4.11    2.78\n                                                   5 columns and 17 rows omitted\n\n\n\nPara verificar quais pacotes do R possuem bancos de dados disponíveis, usamos a função RDatasets.packages.\n\n\nRDatasets.packages()\n\n34×2 DataFrame\n Row │ Package       Title\n     │ String15      String\n─────┼─────────────────────────────────────────────────\n   1 │ COUNT         Functions, data and code for cou…\n   2 │ Ecdat         Data sets for econometrics\n   3 │ HSAUR         A Handbook of Statistical Analys…\n   4 │ HistData      Data sets from the history of st…\n   5 │ ISLR          Data for An Introduction to Stat…\n   6 │ KMsurv        Data sets from Klein and Moeschb…\n   7 │ MASS          Support Functions and Datasets f…\n   8 │ SASmixed      Data sets from \"SAS System for M…\n  ⋮  │      ⋮                        ⋮\n  28 │ reshape2      Flexibly Reshape Data: A Reboot …\n  29 │ robustbase    Basic Robust Statistics\n  30 │ rpart         Recursive Partitioning and Regre…\n  31 │ sandwich      Robust Covariance Matrix Estimat…\n  32 │ sem           Structural Equation Models\n  33 │ survival      Survival Analysis\n  34 │ vcd           Visualizing Categorical Data\n                                        19 rows omitted\n\n\n\nE para verificar quais bancos de dados estão disponíveis em cada pacote, utilizamos a função RDatasets.datasets (onde datasets se refere aos conjuntos de dados do R base).\n\n\nRDatasets.datasets(\"datasets\")\n\n50×5 DataFrame\n Row │ Package   Dataset           Title                              Rows   C ⋯\n     │ String15  String31          String                             Int64  I ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ datasets  BOD               Biochemical Oxygen Demand              6    ⋯\n   2 │ datasets  CO2               Carbon Dioxide Uptake in Grass P…     84\n   3 │ datasets  Formaldehyde      Determination of Formaldehyde          6\n   4 │ datasets  HairEyeColor      Hair and Eye Color of Statistics…     32\n   5 │ datasets  InsectSprays      Effectiveness of Insect Sprays        72    ⋯\n   6 │ datasets  LifeCycleSavings  Intercountry Life-Cycle Savings …     50\n   7 │ datasets  Loblolly          Growth of Loblolly pine trees         84\n   8 │ datasets  OrchardSprays     Potency of Orchard Sprays             64\n  ⋮  │    ⋮             ⋮                          ⋮                    ⋮      ⋱\n  44 │ datasets  sleep             Student's Sleep Data                  20    ⋯\n  45 │ datasets  stackloss         Brownlee's Stack Loss Plant Data      21\n  46 │ datasets  swiss             Swiss Fertility and Socioeconomi…     47\n  47 │ datasets  trees             Girth, Height and Volume for Bla…     31\n  48 │ datasets  volcano           Topographic Information on Auckl…     87    ⋯\n  49 │ datasets  warpbreaks        The Number of Breaks in Yarn dur…     54\n  50 │ datasets  women             Average Heights and Weights for …     15\n                                                    1 column and 35 rows omitted"
  },
  {
    "objectID": "Blog/pacotes_datasets.html#mldatasets.jl",
    "href": "Blog/pacotes_datasets.html#mldatasets.jl",
    "title": "Pacotes com Bancos de Dados para trabalhar em Julia",
    "section": "MLDatasets.jl",
    "text": "MLDatasets.jl\n\nO pacote MLDatasets.jl possui inúmeros bancos de dados com foco em Machine Learning, abrangendo tarefas que vão desde classificação de imagens até treinamento de modelos de linguagem natural. Como exemplo, vamos acessar o clássico conjunto de dados MNIST.\n\n\nMNIST(:train)\n\ndataset MNIST:\n  metadata  =&gt;    Dict{String, Any} with 3 entries\n  split     =&gt;    :train\n  features  =&gt;    28×28×60000 Array{Float32, 3}\n  targets   =&gt;    60000-element Vector{Int64}\n\n\nPara saber quais datasets estão disponíveis no pacote, verifique a documentação oficial ou utilize names(MLDatasets).\n\nnames(MLDatasets)\n\n38-element Vector{Symbol}:\n :AQSOL\n :BostonHousing\n :CIFAR10\n :CIFAR100\n :CachedDataset\n :ChickenPox\n :CiteSeer\n :Cora\n :EMNIST\n :FAUST\n ⋮\n :TUDataset\n :TemporalBrains\n :Titanic\n :UD_English\n :WindMillEnergy\n :Wine\n :convert2image\n :getobs\n :numobs"
  },
  {
    "objectID": "Blog/pacotes_datasets.html#worldbankdata.jl",
    "href": "Blog/pacotes_datasets.html#worldbankdata.jl",
    "title": "Pacotes com Bancos de Dados para trabalhar em Julia",
    "section": "WorldBankData.jl",
    "text": "WorldBankData.jl\n\nO pacote WorldBankData.jl permite acessar diretamente os dados do Banco Mundial. Sua função principal, wdi(), possibilita consultar uma grande variedade de indicadores para diferentes países. Por exemplo, podemos usar essa função para obter a população total do Brasil ao longo dos anos.\n\n\nwdi(\"SP.POP.TOTL\", \"BR\", 1990, 2010)\n\n21×4 DataFrame\n Row │ iso2c   country  year     SP_POP_TOTL\n     │ String  String   Float64  Float64?\n─────┼───────────────────────────────────────\n   1 │ BR      Brazil    1990.0    1.49143e8\n   2 │ BR      Brazil    1991.0    1.51724e8\n   3 │ BR      Brazil    1992.0    1.54275e8\n   4 │ BR      Brazil    1993.0    1.56795e8\n   5 │ BR      Brazil    1994.0    1.59265e8\n   6 │ BR      Brazil    1995.0    1.61735e8\n   7 │ BR      Brazil    1996.0    1.64203e8\n   8 │ BR      Brazil    1997.0    1.66662e8\n  ⋮  │   ⋮        ⋮        ⋮          ⋮\n  15 │ BR      Brazil    2004.0    1.82675e8\n  16 │ BR      Brazil    2005.0    1.84688e8\n  17 │ BR      Brazil    2006.0    1.86653e8\n  18 │ BR      Brazil    2007.0    1.88552e8\n  19 │ BR      Brazil    2008.0    1.90367e8\n  20 │ BR      Brazil    2009.0    1.9208e8\n  21 │ BR      Brazil    2010.0    1.93702e8\n                               6 rows omitted\n\n\n\nPara visualizar a lista de indicadores disponíveis, podemos utilizar a função search_wdi.\n\n\nsearch_wdi(\"indicators\", \"name\", r\".\" )\n\n25000×5 DataFrame\n   Row │ indicator             name                               description  ⋯\n       │ String                String                             String       ⋯\n───────┼────────────────────────────────────────────────────────────────────────\n     1 │ 1.0.HCount.1.90usd    Poverty Headcount ($1.90 a day)    The poverty  ⋯\n     2 │ 1.0.HCount.2.5usd     Poverty Headcount ($2.50 a day)    The poverty\n     3 │ 1.0.HCount.Mid10to50  Middle Class ($10-50 a day) Head…  The poverty\n     4 │ 1.0.HCount.Ofcl       Official Moderate Poverty Rate-N…  The poverty\n     5 │ 1.0.HCount.Poor4uds   Poverty Headcount ($4 a day)       The poverty  ⋯\n     6 │ 1.0.HCount.Vul4to10   Vulnerable ($4-10 a day) Headcou…  The poverty\n     7 │ 1.0.PGap.1.90usd      Poverty Gap ($1.90 a day)          The poverty\n     8 │ 1.0.PGap.2.5usd       Poverty Gap ($2.50 a day)          The poverty\n   ⋮   │          ⋮                            ⋮                               ⋱\n 24994 │ UIS.NART.1.Q5.F       Total net attendance rate, prima…  Total number ⋯\n 24995 │ UIS.NART.1.Q5.F.LPIA  Total net attendance rate, prima…  The Adjusted\n 24996 │ UIS.NART.1.Q5.GPIA    Total net attendance rate, prima…  The Adjusted\n 24997 │ UIS.NART.1.Q5.LPIA    Total net attendance rate, prima…  The Adjusted\n 24998 │ UIS.NART.1.Q5.M       Total net attendance rate, prima…  Total number ⋯\n 24999 │ UIS.NART.1.Q5.M.LPIA  Total net attendance rate, prima…  The Adjusted\n 25000 │ UIS.NART.1.RUR        Total net attendance rate, prima…  Total number\n                                                3 columns and 24985 rows omitted"
  },
  {
    "objectID": "Blog/pacotes_datasets.html#yfinance.jl",
    "href": "Blog/pacotes_datasets.html#yfinance.jl",
    "title": "Pacotes com Bancos de Dados para trabalhar em Julia",
    "section": "YFinance.jl",
    "text": "YFinance.jl\n\nO pacote YFinance.jl oferece uma maneira prática de acessar dados de ações, embora apresente algumas limitações de uso. Para carregar os dados, utilizamos a função get_prices(), na qual podemos especificar o ativo desejado, o intervalo total e a frequência das observações.\n\n\nget_prices(\"AAPL\", range=\"1y\", interval=\"1d\")\n\nOrderedCollections.OrderedDict{String, Union{Vector{Float64}, Vector{Dates.DateTime}, String}} with 8 entries:\n  \"ticker\"    =&gt; \"AAPL\"\n  \"timestamp\" =&gt; [DateTime(\"2024-09-19T13:30:00\"), DateTime(\"2024-09-20T13:30:0…\n  \"open\"      =&gt; [223.948, 228.905, 226.287, 227.591, 223.888, 226.247, 227.402…\n  \"high\"      =&gt; [228.755, 232.01, 228.387, 228.288, 226.237, 227.441, 228.457,…\n  \"low\"       =&gt; [223.589, 226.566, 224.764, 224.684, 222.982, 224.366, 226.247…\n  \"close\"     =&gt; [228.87, 228.2, 226.47, 227.37, 226.37, 227.52, 227.79, 233.0,…\n  \"adjclose\"  =&gt; [227.81, 227.143, 225.421, 226.317, 225.321, 226.466, 226.735,…\n  \"vol\"       =&gt; [6.64719e7, 3.17204e8, 5.38952e7, 4.33543e7, 4.21127e7, 3.6467…"
  },
  {
    "objectID": "Blog/pacotes_datasets.html#conclusão",
    "href": "Blog/pacotes_datasets.html#conclusão",
    "title": "Pacotes com Bancos de Dados para trabalhar em Julia",
    "section": "Conclusão",
    "text": "Conclusão\n\nPortanto, agora você já sabe como acessar diversos conjuntos de dados em Julia para suas análises estatísticas. Para continuar aprendendo, escolha um dos pacotes apresentados, explore os dados disponíveis e tente realizar uma análise completa.\nPara auxiliar nesse processo, recomendamos os tutoriais Introdução à Análise Exploratória de Dados (EDA) em Julia e Gráficos em Julia: primeiros passos, publicados aqui no Do Zero ao Julia.\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "oprojeto.html",
    "href": "oprojeto.html",
    "title": "Conheça mais sobre o projeto ‘Do Zero ao Julia’",
    "section": "",
    "text": "Julia?\n\nA linguagem de programação Julia, lançada oficialmente ao público em 2012, e com foco em ciência de dados e computação científica, tem surgido como uma alternativa a outras linguagem de programação já estabelecidas no mercado como Matlab, Python e R. Com desempenho comparável ao de C++ e facilidade de aprendizado similar a Python e R, Julia utiliza multiple dispatch, tem uma boa performance e permite utilizar símbolos matemáticos diretamente no código. Ademais, Julia também resolve o problema de duas linguagens, não sendo mais necessário fazer o protótipo em uma linguagem e colocar em produção em outra – uma característica especialmente vantajosa no desenvolvimento de aplicações no setor industrial e em projetos de grande escala.\n\n\n\nO Projeto\n\nDo Zero ao Julia é um projeto de extensão do IMECC/UNICAMP, coordenado pelo Professor Carlos Trucíos (Departamento de Estatística), com o objetivo de incentivar e disseminar o uso da linguagem Julia. O projeto visa destacar Julia como uma ferramenta poderosa e eficiente, não apenas no ensino de Estatística e Ciência de Dados, mas também como uma ferramenta poderosa na análise de dados, desenvolvimento de projetos e implantação de modelos tanto na academia quanto na industria. Através de palestras, cursos online e materiais educativos, como blogs e tutoriais, vamos apresentar os benefícios e recursos da linguagem de programação Julia a diferentes públicos. O projeto será uma oportunidade para envolver tanto a comunidade acadêmica quanto outras pessoas interessadas, como profissionais da indústria, buscando promover a troca de conhecimentos e fortalecer a conexão entre a universidade e a sociedade.\n\n\nAlém disso, o projeto irá oferecer materiais comparando Julia com outras linguagens populares, como Python e R, mostrando suas vantagens, limitações e características específicas. Também será explorado como Julia pode ser integrada com outras tecnologias, com foco na implementação de modelos em produção, proporcionando uma visão abrangente de como Julia se posiciona no vasto ecossistema de ferramentas tecnológicas da era digital."
  },
  {
    "objectID": "Tutoriais/loops_condicionais_julia.html",
    "href": "Tutoriais/loops_condicionais_julia.html",
    "title": "Loops e Condicionais em Julia",
    "section": "",
    "text": "Julia é uma linguagem de programação de alto desempenho voltada para computação científica e análise de dados. Neste artigo, vamos explorar dois dos principais mecanismos de controle de fluxo de sua sintaxe poderosa: loops (laços de repetição) e condicionais. Com eles, você pode automatizar tarefas repetitivas e tomar decisões baseadas em condições, enquanto desenvolve códigos mais flexíveis e eficientes."
  },
  {
    "objectID": "Tutoriais/loops_condicionais_julia.html#introdução",
    "href": "Tutoriais/loops_condicionais_julia.html#introdução",
    "title": "Loops e Condicionais em Julia",
    "section": "",
    "text": "Julia é uma linguagem de programação de alto desempenho voltada para computação científica e análise de dados. Neste artigo, vamos explorar dois dos principais mecanismos de controle de fluxo de sua sintaxe poderosa: loops (laços de repetição) e condicionais. Com eles, você pode automatizar tarefas repetitivas e tomar decisões baseadas em condições, enquanto desenvolve códigos mais flexíveis e eficientes."
  },
  {
    "objectID": "Tutoriais/loops_condicionais_julia.html#condicionais",
    "href": "Tutoriais/loops_condicionais_julia.html#condicionais",
    "title": "Loops e Condicionais em Julia",
    "section": "Condicionais",
    "text": "Condicionais\n\nEm Julia, a estrutura condicional é semelhante à de outras linguagens, como Python e C. Utilizam-se comandos como if, elseif e else para controlar o fluxo de execução de um programa, permitindo a tomada de decisões baseada em condições booleanas (ou seja, que podem ser verdadeiras ou falsas).\n\n\nSintaxe básica:\nif condição_1\n   \nelseif condição_2\n    \nelse\n    condição_complementar\nend\n\n\nExemplo:\n\nx = 50;\n\nif x &gt; 0\n    println(\"x é positivo\")\nelseif x &lt; 0\n    println(\"x é negativo\")\nelse\n    println(\"x é zero\")\nend\n\nx é positivo\n\n\nif é uma estrutura condicional inicial. Se a condição for verdadeira (true), o bloco de código dentro de if será executado. Caso contrário (ou seja, se a condição for falsa (false)), o programa dará continuidade em elseif ou else, caso existam. Se não houver outras condições, o bloco será ignorado.\n\n\n\n\n\n\nObservação\n\n\n\n\nend sempre fecha a estrutura.\nParênteses não são necessários.\n\n\n\n\n\nOperador ternário\nO operador ternário é uma forma alternativa e mais concisa de escrever uma expressão condicional em uma única linha. Ele serve para escolher entre dois valores com base em uma condição booleana, sendo uma alternativa mais compacta ao tradicional if-else.\ncondição ? valor_verdadeiro : valor_falso\n\nExemplo:\n\nx = 50;\nresultado = x &gt; 5 ? \"Maior que 5\" : \"Menor ou igual a 5\";\nresultado\n\n\"Maior que 5\"\n\n\n\n\nEquivalência com if-else:\n\nx = 50;\nif x &gt; 5\n    resultado = \"Maior que 5\";\nelse\n    resultado = \"Menor ou igual a 5\";\nend\n\n\"Maior que 5\"\n\n\n\nUse o operador ternário quando a condição for simples e o resultado for um valor ou expressão curtos. Evite-o quando a lógica for complexa ou envolver muitos passos, pois pode dificultar a leitura."
  },
  {
    "objectID": "Tutoriais/loops_condicionais_julia.html#loops",
    "href": "Tutoriais/loops_condicionais_julia.html#loops",
    "title": "Loops e Condicionais em Julia",
    "section": "Loops",
    "text": "Loops\nLoops são estruturas fundamentais em qualquer linguagem de programação, e em Julia eles são especialmente eficientes e versáteis. Loops permitem executar repetidamente um bloco de código, facilitando a automação de tarefas repetitivas. Em Julia, as principais estruturas de repetição são for e while. Além disso, a linguagem oferece comandos como break e continue para controlar o fluxo dentro dos loops, e funções como zip para iterar simultaneamente sobre múltiplas coleções.\n\nLoop for\nO loop for é usado para iterar sobre uma coleção de elementos, como vetores, ranges, strings ou quaisquer objetos iteráveis.\nfor variável in coleção\n    # condição a ser testada\nend\nNo caso dessa condicional, for é o que irá definir o loop, in definirá o intervalo de iteração (que depende da variável que você declarou para ser condicionada ao loop) e end indica o fim do loop.\n\nExemplos:\n\n# Loop for em um range\nprint(\"\\nIteração em range:\\n\")\n\n\nIteração em range:\n\nfor i in 1:5\n    println(\"O valor de i é \", i)\nend\n\nO valor de i é 1\nO valor de i é 2\nO valor de i é 3\nO valor de i é 4\nO valor de i é 5\n\n\n\n# Loop for em uma lista\nprint(\"\\nIteração em lista:\\n\")\n\n\nIteração em lista:\n\nnomes = [\"Ana\", \"Bruno\", \"Carlos\"];\nfor nome in nomes\n    println(\"Olá, \", nome, \"!\")\nend\n\nOlá, Ana!\nOlá, Bruno!\nOlá, Carlos!\n\n\n\n# Loop for em uma tupla\nprint(\"\\nIteração em tupla:\\n\") \n\n\nIteração em tupla:\n\nt = (\"Do\", \"Zero\", \"ao\", \"Julia\");\nfor i in t\n    println(i) \nend\n\nDo\nZero\nao\nJulia\n\n\n\n\n\nLoop while\nO loop while executa repetidamente um bloco de código enquanto uma condição estabelecida for verdadeira. Analogamente ao for, o código passa a executar a linha ou o chunk seguinte do loop. E, caso a condição inicial seja falsa, o chunk apenas será ignorado.\n\nSintaxe básica:\nwhile condição\n    # condição a ser testada\nend\n\n\nExemplo:\n\n# Uso do while com a sequência de Fibonacci \nlen = 10;\n\n# Primeiros dois valores\na = 0;\nb = 1;\n\n# Valor de iteração\nitr = 0;\n\nwhile itr &lt; len\n   print(a, \", \")\n  \n   c = a + b\n   \n   global a = b\n   global b = c\n   \n   global itr += 1\n   \nend\n\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \n\n\n\nUse while quando não souber exatamente quantas repetições são necessárias mas souber quando parar. Um while true cria um loop infinito. Apenas use-o caso esteja certo de que haverá uma condição de parada interna, como break."
  },
  {
    "objectID": "Tutoriais/loops_condicionais_julia.html#controlando-for-e-while-com-break-e-continue",
    "href": "Tutoriais/loops_condicionais_julia.html#controlando-for-e-while-com-break-e-continue",
    "title": "Loops e Condicionais em Julia",
    "section": "Controlando for e while com break e continue",
    "text": "Controlando for e while com break e continue\nJulia oferece duas instruções importantes para controlar o fluxo dentro de loops: break e continue.\n\nBreak\nA palavra-chave break é usada em Julia para parar um loop imediatamente. Quando ela é executada, o compilador encerra o loop de maneira abrupta, executando, em seguida, o chunk fora do loop.\n\nSintaxe básica:\nLoop\n    # condição a ser testada\n    break\n    # condição complementar\nend\n\n\nExemplo:\n\nfor i in 1:10\n    if i == 5\n        break\n    end\n    println(i)\nend\n\n1\n2\n3\n4\n\n\n\n\n\nContinue\nA palavra-chave continue faz com que o loop pule o restante do bloco de código da iteração atual e passe imediatamente para a próxima iteração. Ou seja, ela interrompe a execução do código atual dentro do loop, avançando para o próximo ciclo.\n\nSintaxe básica:\nLoop\n    # condição a ser testada\n    continue\n    # condição complementar\nend\n\n\nExemplo:\n\nfor i in 1:5\n    if i == 3\n        continue\n    end\n    println(i)\nend\n\n1\n2\n4\n5\n\n\n\n\n\nIterando sobre múltiplas coleções\nA função zip é uma ferramenta muito útil em Julia para trabalhar simultaneamente com múltiplas coleções, como listas e vetores. zip cria um iterador que combina essas coleções. Em cada iteração, ele retorna uma tupla contendo os elementos correspondentes de cada coleção.\n\nSintaxe básica:\n{zip(coleção_1, coleção_2, ...)}\nDepois, você pode iterar sobre esse zip com um for.\nExemplos:\n\nnomes = [\"Ana\", \"Bruno\", \"Carlos\"];\nidades = [25, 30, 22];\n\nfor (nome, idade) in zip(nomes, idades)\n    println(\"$nome tem $idade anos\")\nend\n\nAna tem 25 anos\nBruno tem 30 anos\nCarlos tem 22 anos\n\n\n\nO zip termina na coleção mais curta.\n\n\n# Exemplo com listas de tamanhos diferentes\na = [1, 2, 3, 4];\nb = [\"x\", \"y\"];\n\nfor (num, letra) in zip(a, b)\n    println(\"$num =&gt; $letra\")\nend\n\n1 =&gt; x\n2 =&gt; y\n\n\n\n\n\n\n\n\nBônus\n\n\n\nNão é raro termos dois loop dentro de uma mesma tarefa. Em Julia, podemos incluir ambos iteradores de forma simples\n\nfor (i, j) in Iterators.product(1:5, 10:10:30)\n  println(\"Iterador i:  \", i, \", iterador j: \", j)\nend\n\nIterador i:  1, iterador j: 10\nIterador i:  2, iterador j: 10\nIterador i:  3, iterador j: 10\nIterador i:  4, iterador j: 10\nIterador i:  5, iterador j: 10\nIterador i:  1, iterador j: 20\nIterador i:  2, iterador j: 20\nIterador i:  3, iterador j: 20\nIterador i:  4, iterador j: 20\nIterador i:  5, iterador j: 20\nIterador i:  1, iterador j: 30\nIterador i:  2, iterador j: 30\nIterador i:  3, iterador j: 30\nIterador i:  4, iterador j: 30\nIterador i:  5, iterador j: 30\n\n\n\nfor i in 1:5, j in 10:10:30\n  println(\"Iterador i:  \", i, \", iterador j: \", j)\nend\n\nIterador i:  1, iterador j: 10\nIterador i:  1, iterador j: 20\nIterador i:  1, iterador j: 30\nIterador i:  2, iterador j: 10\nIterador i:  2, iterador j: 20\nIterador i:  2, iterador j: 30\nIterador i:  3, iterador j: 10\nIterador i:  3, iterador j: 20\nIterador i:  3, iterador j: 30\nIterador i:  4, iterador j: 10\nIterador i:  4, iterador j: 20\nIterador i:  4, iterador j: 30\nIterador i:  5, iterador j: 10\nIterador i:  5, iterador j: 20\nIterador i:  5, iterador j: 30\n\n\n\nfor i in 1:5, j in i:2:10\n  println(\"Iterador i:  \", i, \", iterador j: \", j)\nend\n\nIterador i:  1, iterador j: 1\nIterador i:  1, iterador j: 3\nIterador i:  1, iterador j: 5\nIterador i:  1, iterador j: 7\nIterador i:  1, iterador j: 9\nIterador i:  2, iterador j: 2\nIterador i:  2, iterador j: 4\nIterador i:  2, iterador j: 6\nIterador i:  2, iterador j: 8\nIterador i:  2, iterador j: 10\nIterador i:  3, iterador j: 3\nIterador i:  3, iterador j: 5\nIterador i:  3, iterador j: 7\nIterador i:  3, iterador j: 9\nIterador i:  4, iterador j: 4\nIterador i:  4, iterador j: 6\nIterador i:  4, iterador j: 8\nIterador i:  4, iterador j: 10\nIterador i:  5, iterador j: 5\nIterador i:  5, iterador j: 7\nIterador i:  5, iterador j: 9"
  },
  {
    "objectID": "Tutoriais/loops_condicionais_julia.html#considerações-finais",
    "href": "Tutoriais/loops_condicionais_julia.html#considerações-finais",
    "title": "Loops e Condicionais em Julia",
    "section": "Considerações finais",
    "text": "Considerações finais\nVerificamos, portanto, que tanto os loops quanto as condicionais são componentes essenciais para o desenvolvimento de códigos eficientes em Julia. Enquanto as condicionais permitem que seu programa tome decisões com base em regras lógicas, os loops possibilitam repetir ações automaticamente, reduzindo redundância e aumentando a performance em tarefas como simulações, análises de dados ou algoritmos numéricos.\n\nExplore mais: Comprehensions são uma forma compacta de criar vetores, matrizes e até dicionários. Elas podem ser muito mais rápidas que loops utilizando push!.\n\nReferências e mais detalhes podem ser encontrados nesses endereços web:\n\nGeeks for Geeks\njlHub\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html",
    "href": "Tutoriais/tutorial-eda.html",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "",
    "text": "A Análise Exploratória de Dados (EDA) é uma etapa fundamental na Ciência de Dados. Seu objetivo é entender a estrutura dos dados, identificar padrões, encontrar anomalias e formular hipóteses. Com a linguagem julia, voltada para alto desempenho e cálculo científico, a EDA pode ser feita de forma rápida e eficiente.\n\n\n\n\nDesempenho comparável ao C\nSintaxe limpa e legível\nGrande suporte para operações matemáticas e estatísticas\nEcossistema em crescimento com diversas bibliotecas voltadas para dados\nIntegração com outras linguagens como Python, R e C/C++"
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#benefícios-de-usar-julia-para-eda",
    "href": "Tutoriais/tutorial-eda.html#benefícios-de-usar-julia-para-eda",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "",
    "text": "Desempenho comparável ao C\nSintaxe limpa e legível\nGrande suporte para operações matemáticas e estatísticas\nEcossistema em crescimento com diversas bibliotecas voltadas para dados\nIntegração com outras linguagens como Python, R e C/C++"
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#instalação-de-pacotes-essenciais",
    "href": "Tutoriais/tutorial-eda.html#instalação-de-pacotes-essenciais",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Instalação de Pacotes Essenciais",
    "text": "Instalação de Pacotes Essenciais\n\nimport Pkg\n\n# Suprime mensagens e warnings durante a instalação dos pacotes\nredirect_stdout(devnull) do\n    redirect_stderr(devnull) do\n        Pkg.add(\"RDatasets\")     # Datasets clássicos;\n        Pkg.add(\"StatsBase\")     # Estatísticas descritivas;\n        Pkg.add(\"StatsPlots\")    # Visualizações estatísticas;\n        Pkg.add(\"Distributions\") # Distribuições estatísticas;\n        Pkg.add(\"Random\")        # Geração de números aleatórios;\n        Pkg.add(\"DataFrames\")    # Estrutura tipo planilha;\n        Pkg.add(\"Plots\")         # Biblioteca de gráficos;\n        Pkg.add(\"Statistics\")    # Funções como mean, median, etc;\n        Pkg.add(\"Dates\")         # Manipulação de datas.\n        Pkg.add(\"Measures\")      # Formatação\n    end\nend\n\n# Obs.: Apenas precisamos carregar o pacote uma vez por ambiente.\n\n\nDica: Use Pkg.instantiate() para garantir que todas as dependências do seu projeto estejam resolvidas."
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#carregando-um-conjunto-de-dados",
    "href": "Tutoriais/tutorial-eda.html#carregando-um-conjunto-de-dados",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Carregando um Conjunto de Dados",
    "text": "Carregando um Conjunto de Dados\n\nusing RDatasets\niris = dataset(\"datasets\", \"iris\")\n\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     Cat…\n─────┼─────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  setosa\n   2 │         4.9         3.0          1.4         0.2  setosa\n   3 │         4.7         3.2          1.3         0.2  setosa\n   4 │         4.6         3.1          1.5         0.2  setosa\n   5 │         5.0         3.6          1.4         0.2  setosa\n   6 │         5.4         3.9          1.7         0.4  setosa\n   7 │         4.6         3.4          1.4         0.3  setosa\n   8 │         5.0         3.4          1.5         0.2  setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮           ⋮\n 144 │         6.8         3.2          5.9         2.3  virginica\n 145 │         6.7         3.3          5.7         2.5  virginica\n 146 │         6.7         3.0          5.2         2.3  virginica\n 147 │         6.3         2.5          5.0         1.9  virginica\n 148 │         6.5         3.0          5.2         2.0  virginica\n 149 │         6.2         3.4          5.4         2.3  virginica\n 150 │         5.9         3.0          5.1         1.8  virginica\n                                                   135 rows omitted\n\nfirst(iris, 5) # Visualização inicial das 5 primeiras linhas do dataset.\n\n5×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     Cat…\n─────┼───────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  setosa\n   2 │         4.9         3.0          1.4         0.2  setosa\n   3 │         4.7         3.2          1.3         0.2  setosa\n   4 │         4.6         3.1          1.5         0.2  setosa\n   5 │         5.0         3.6          1.4         0.2  setosa\n\n\nO conjunto de dados Iris é um clássico da estatística e aprendizado de máquina. Ele contém medidas de sépalas e pétalas de três espécies de flores: Setosa, Versicolor e Virginica."
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#correlação-entre-variáveis",
    "href": "Tutoriais/tutorial-eda.html#correlação-entre-variáveis",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Correlação entre variáveis",
    "text": "Correlação entre variáveis\n\n# Calculando a correlação de Pearson entre duas variáveis numéricas, e depois descrevendo uma das colunas\n\ncorrelacao = cor(iris.SepalWidth, iris.SepalLength)\n\n-0.11756978413300205\n\nprintln(\"Correlação entre SepalWidth e SepalLength: \", correlacao)\n\nCorrelação entre SepalWidth e SepalLength: -0.11756978413300205\n\n\nAqui, vemos a correlação de Pearson para as variáveis SepalWidth e SepalLength usando a função cor()."
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#criando-novas-colunas",
    "href": "Tutoriais/tutorial-eda.html#criando-novas-colunas",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Criando novas colunas",
    "text": "Criando novas colunas\n\nusing Distributions, Random, DataFrames\n# Agora vamos adicionar uma nova coluna ao nosso dataset\nRandom.seed!(123) # Tornando os resultados reprodutíveis\n\nTaskLocalRNG()\n\niris.soma_col = iris.SepalWidth + iris.PetalWidth\n\n150-element Vector{Float64}:\n 3.7\n 3.2\n 3.4000000000000004\n 3.3000000000000003\n 3.8000000000000003\n 4.3\n 3.6999999999999997\n 3.6\n 3.1\n 3.2\n ⋮\n 5.4\n 4.6\n 5.5\n 5.8\n 5.3\n 4.4\n 5.0\n 5.699999999999999\n 4.8\n\niris.normal_padrao = randn(150)\n\n150-element Vector{Float64}:\n  0.8082879284649668\n -1.1220725081141734\n -1.1046361023292959\n -0.4169926351649334\n  0.28758798062385577\n  0.2298186980518676\n -0.4217686643996927\n -1.355590621101197\n  0.0694591410918936\n -0.11732280453081337\n  ⋮\n -0.5245917996070839\n  1.2770297791112688\n -1.0890471538422415\n -1.088218513936287\n  0.7037583257923017\n  0.14332589323751366\n  0.14837536667608195\n  1.0096134137351438\n  0.028766636052271793\n\niris.normal = rand(Normal(2, 0.5), 150)\n\n150-element Vector{Float64}:\n 1.8549928474436481\n 2.062061985303628\n 2.016057255141819\n 2.1161454686338543\n 1.3673429647209598\n 1.4120172154505015\n 1.9308005375653\n 1.6049470900443568\n 3.5293684931000344\n 1.0763261317866746\n ⋮\n 2.326721880967805\n 1.949391560407876\n 1.9438071314340073\n 2.728684959145093\n 2.259371762456528\n 1.7372020985648153\n 2.5003474504889027\n 1.377130936042281\n 2.3064311304205996\n\n# Perceba que conseguimos criar uma normal padrão usando a função randn(). Já para uma normal com outros parêmtros de locação e escala utilizamos a função Normal()\nfirst(iris, 5)\n\n5×8 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species  soma_col  no ⋯\n     │ Float64      Float64     Float64      Float64     Cat…     Float64   Fl ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  setosa        3.7     ⋯\n   2 │         4.9         3.0          1.4         0.2  setosa        3.2\n   3 │         4.7         3.2          1.3         0.2  setosa        3.4\n   4 │         4.6         3.1          1.5         0.2  setosa        3.3\n   5 │         5.0         3.6          1.4         0.2  setosa        3.8     ⋯\n                                                               2 columns omitted\n\n\nCaso queira adicionar uma nova coluna ao seu dataset, por exemplo, comparar a soma - largura da sépala com a largura da pétala - para cada flor, apenas nomeie a sua nova coluna no formato dados.nova_coluna = nova_coluna. É importante ressaltar que len(nova_coluna) = len(dados.coluna_qualquer), ou seja, o tamanho n da coluna (150 observações, no nosso exemplo) tem que ser igual no dataset inteiro."
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#filtragem-de-dados",
    "href": "Tutoriais/tutorial-eda.html#filtragem-de-dados",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Filtragem de dados",
    "text": "Filtragem de dados\n\n# Agora vejamos como filtrar valores no nosso dataset\nflores_grandes = filter(row -&gt; row.SepalLength &gt; 7, iris) # Filtrando apenas as flores cuja sépala mede mais do que 7cm\n\n12×8 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species    soma_col   ⋯\n     │ Float64      Float64     Float64      Float64     Cat…       Float64    ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │         7.1         3.0          5.9         2.1  virginica       5.1   ⋯\n   2 │         7.6         3.0          6.6         2.1  virginica       5.1\n   3 │         7.3         2.9          6.3         1.8  virginica       4.7\n   4 │         7.2         3.6          6.1         2.5  virginica       6.1\n   5 │         7.7         3.8          6.7         2.2  virginica       6.0   ⋯\n   6 │         7.7         2.6          6.9         2.3  virginica       4.9\n   7 │         7.7         2.8          6.7         2.0  virginica       4.8\n   8 │         7.2         3.2          6.0         1.8  virginica       5.0\n   9 │         7.2         3.0          5.8         1.6  virginica       4.6   ⋯\n  10 │         7.4         2.8          6.1         1.9  virginica       4.7\n  11 │         7.9         3.8          6.4         2.0  virginica       5.8\n  12 │         7.7         3.0          6.1         2.3  virginica       5.3\n                                                               2 columns omitted\n\n# flores_grandes1 = iris[iris.SepalLength .&gt; 7, :] Outra forma de filtrar\nfirst(flores_grandes, 5)\n\n5×8 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species    soma_col   ⋯\n     │ Float64      Float64     Float64      Float64     Cat…       Float64    ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │         7.1         3.0          5.9         2.1  virginica       5.1   ⋯\n   2 │         7.6         3.0          6.6         2.1  virginica       5.1\n   3 │         7.3         2.9          6.3         1.8  virginica       4.7\n   4 │         7.2         3.6          6.1         2.5  virginica       6.1\n   5 │         7.7         3.8          6.7         2.2  virginica       6.0   ⋯\n                                                               2 columns omitted\n\n\nPara filtrar nossos dados, podemos usar a função filter(), no formato filter(row ou col -&gt; condição, dados) e assim criamos uma condição para filtrar as linhas do dataset. Uma alternativa seria usar o formato dados[condição, :]."
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#agrupamento-e-seleção",
    "href": "Tutoriais/tutorial-eda.html#agrupamento-e-seleção",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Agrupamento e seleção",
    "text": "Agrupamento e seleção\nSelecionando as colunas SepalLength e PetalWidth para análise.\n\n# Como selecionar e agrupar colunas\nselecao = select(iris, :SepalLength, :PetalWidth) # Selecionando colunas\n\n150×2 DataFrame\n Row │ SepalLength  PetalWidth\n     │ Float64      Float64\n─────┼─────────────────────────\n   1 │         5.1         0.2\n   2 │         4.9         0.2\n   3 │         4.7         0.2\n   4 │         4.6         0.2\n   5 │         5.0         0.2\n   6 │         5.4         0.4\n   7 │         4.6         0.3\n   8 │         5.0         0.2\n  ⋮  │      ⋮           ⋮\n 144 │         6.8         2.3\n 145 │         6.7         2.5\n 146 │         6.7         2.3\n 147 │         6.3         1.9\n 148 │         6.5         2.0\n 149 │         6.2         2.3\n 150 │         5.9         1.8\n               135 rows omitted\n\nfirst(selecao, 5)\n\n5×2 DataFrame\n Row │ SepalLength  PetalWidth\n     │ Float64      Float64\n─────┼─────────────────────────\n   1 │         5.1         0.2\n   2 │         4.9         0.2\n   3 │         4.7         0.2\n   4 │         4.6         0.2\n   5 │         5.0         0.2\n\n\nDataframes agrupados por Species.\n\ngrupo = groupby(iris, :Species) # Agrupando por categorias de uma colunas, nesse caso por espécie (virginica, setosa e versicolor)\n\nGroupedDataFrame with 3 groups based on key: Species\nFirst Group (50 rows): Species = CategoricalArrays.CategoricalValue{String, UInt8} \"setosa\"\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species  soma_col  no ⋯\n     │ Float64      Float64     Float64      Float64     Cat…     Float64   Fl ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  setosa        3.7     ⋯\n   2 │         4.9         3.0          1.4         0.2  setosa        3.2\n  ⋮  │      ⋮           ⋮            ⋮           ⋮          ⋮        ⋮         ⋱\n  49 │         5.3         3.7          1.5         0.2  setosa        3.9\n  50 │         5.0         3.3          1.4         0.2  setosa        3.5\n                                                   2 columns and 46 rows omitted\n⋮\nLast Group (50 rows): Species = CategoricalArrays.CategoricalValue{String, UInt8} \"virginica\"\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species    soma_col   ⋯\n     │ Float64      Float64     Float64      Float64     Cat…       Float64    ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │         6.3         3.3          6.0         2.5  virginica       5.8   ⋯\n   2 │         5.8         2.7          5.1         1.9  virginica       4.6\n  ⋮  │      ⋮           ⋮            ⋮           ⋮           ⋮         ⋮       ⋱\n  50 │         5.9         3.0          5.1         1.8  virginica       4.8\n                                                   2 columns and 47 rows omitted"
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#aplicação-de-funções-e-ordenação",
    "href": "Tutoriais/tutorial-eda.html#aplicação-de-funções-e-ordenação",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Aplicação de funções e ordenação",
    "text": "Aplicação de funções e ordenação\nAplicando a função y = log(x) para a coluna SepalLength, retornando o vetor de valores y.\n\nfirst(map(x -&gt; log(x), iris.SepalLength), 10)\n\n10-element Vector{Float64}:\n 1.62924053973028\n 1.589235205116581\n 1.547562508716013\n 1.5260563034950492\n 1.6094379124341003\n 1.6863989535702288\n 1.5260563034950492\n 1.6094379124341003\n 1.4816045409242156\n 1.589235205116581\n\n\nOrdenando o dataset com base no tamanho da pétala (PetalLength), em ordem crescente.\n\nfirst(sort(iris, :PetalLength), 10)\n\n10×8 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species  soma_col  no ⋯\n     │ Float64      Float64     Float64      Float64     Cat…     Float64   Fl ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │         4.6         3.6          1.0         0.2  setosa        3.8     ⋯\n   2 │         4.3         3.0          1.1         0.1  setosa        3.1\n   3 │         5.8         4.0          1.2         0.2  setosa        4.2\n   4 │         5.0         3.2          1.2         0.2  setosa        3.4\n   5 │         4.7         3.2          1.3         0.2  setosa        3.4     ⋯\n   6 │         5.4         3.9          1.3         0.4  setosa        4.3\n   7 │         5.5         3.5          1.3         0.2  setosa        3.7\n   8 │         4.4         3.0          1.3         0.2  setosa        3.2\n   9 │         5.0         3.5          1.3         0.3  setosa        3.8     ⋯\n  10 │         4.5         2.3          1.3         0.3  setosa        2.6\n                                                               2 columns omitted\n\n\n\nÉ importante lembrar que muitas dessas funções possuem muita importância durante o tratamento dos dados no início de uma análise, mas também durante a criação de gráficos e tabelas."
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#histogramas-e-scatterplots",
    "href": "Tutoriais/tutorial-eda.html#histogramas-e-scatterplots",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Histogramas e Scatterplots",
    "text": "Histogramas e Scatterplots\nCriando histogramas e scatterplots para visualizar a distribuição dos dados\n\nusing Plots\nusing Measures\n\nplot(\n    histogram(iris.SepalWidth, title=\"Distribuição da Largura da Sépala\", xlabel=\"Largura\", ylabel=\"Frequência\", margin=5mm, label=\"\"),\n    scatter(iris.PetalWidth, iris.PetalLength, title=\"Largura x Comprimento da Pétala\", xlabel=\"Largura\", ylabel=\"Comprimento\", margin=5mm, label=\"\"),\n    layout=(1, 2),\n    size=(900, 400)\n)\n\n\n\n\n\n\n\n\nGráficos de dispersão (scatterplots) são úteis para visualizar a relação entre duas variáveis contínuas, enquanto histogramas ajudam a entender a distribuição de uma única variável. Vamos agora aprender filtrar e selecionar os dados que queremos visualizar.\n\nusing StatsPlots\n\n# Filtrando apenas as linhas com Species == \"virginica\"\nvirginica = filter(row -&gt; row.Species == \"virginica\", iris)\n\n50×8 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species    soma_col   ⋯\n     │ Float64      Float64     Float64      Float64     Cat…       Float64    ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │         6.3         3.3          6.0         2.5  virginica       5.8   ⋯\n   2 │         5.8         2.7          5.1         1.9  virginica       4.6\n   3 │         7.1         3.0          5.9         2.1  virginica       5.1\n   4 │         6.3         2.9          5.6         1.8  virginica       4.7\n   5 │         6.5         3.0          5.8         2.2  virginica       5.2   ⋯\n   6 │         7.6         3.0          6.6         2.1  virginica       5.1\n   7 │         4.9         2.5          4.5         1.7  virginica       4.2\n   8 │         7.3         2.9          6.3         1.8  virginica       4.7\n  ⋮  │      ⋮           ⋮            ⋮           ⋮           ⋮         ⋮       ⋱\n  44 │         6.8         3.2          5.9         2.3  virginica       5.5   ⋯\n  45 │         6.7         3.3          5.7         2.5  virginica       5.8\n  46 │         6.7         3.0          5.2         2.3  virginica       5.3\n  47 │         6.3         2.5          5.0         1.9  virginica       4.4\n  48 │         6.5         3.0          5.2         2.0  virginica       5.0   ⋯\n  49 │         6.2         3.4          5.4         2.3  virginica       5.7\n  50 │         5.9         3.0          5.1         1.8  virginica       4.8\n                                                   2 columns and 35 rows omitted\n\n\n# Selecionando apenas as colunas de interesse, nesse caso SepalWidth e PetalLength\n\ndados_virg = select(virginica, :SepalWidth, :PetalLength)\n\n50×2 DataFrame\n Row │ SepalWidth  PetalLength\n     │ Float64     Float64\n─────┼─────────────────────────\n   1 │        3.3          6.0\n   2 │        2.7          5.1\n   3 │        3.0          5.9\n   4 │        2.9          5.6\n   5 │        3.0          5.8\n   6 │        3.0          6.6\n   7 │        2.5          4.5\n   8 │        2.9          6.3\n  ⋮  │     ⋮            ⋮\n  44 │        3.2          5.9\n  45 │        3.3          5.7\n  46 │        3.0          5.2\n  47 │        2.5          5.0\n  48 │        3.0          5.2\n  49 │        3.4          5.4\n  50 │        3.0          5.1\n                35 rows omitted\n\n\n# Scatterplot\nscatter(dados_virg.SepalWidth, dados_virg.PetalLength,\n        xlabel = \"SepalWidth\",\n        ylabel = \"PetalLength\",\n        title = \"Virginica: SepalWidth vs PetalLength\",\n        legend = false)"
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#boxplots-e-gráficos-de-barras",
    "href": "Tutoriais/tutorial-eda.html#boxplots-e-gráficos-de-barras",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Boxplots e Gráficos de Barras",
    "text": "Boxplots e Gráficos de Barras\n\nusing DataFrames, StatsPlots\n\n# Criando boxplots e gráficos de barras para visualizar a distribuição dos dados\n\nbox = boxplot(iris.Species, iris.SepalLength, xlabel=\"Espécie\", ylabel=\"Comprimento da Sépala\", title=\"Boxplot do SepalLength por Espécie\", label=\"\")\n\n\n\n\n\n\n\n\n# Agrupando por espécie e calculando a média do comprimento da pétala\nresumo = combine(groupby(iris, :Species), :SepalWidth =&gt; mean =&gt; :MediaSepalWidth)\n\n3×2 DataFrame\n Row │ Species     MediaSepalWidth\n     │ Cat…        Float64\n─────┼─────────────────────────────\n   1 │ setosa                3.428\n   2 │ versicolor            2.77\n   3 │ virginica             2.974\n\n\n# Gráfico de barras\nbarras = bar(resumo.Species, resumo.MediaSepalWidth,\n    xlabel = \"Espécie\",\n    ylabel = \"Média do SepalWidth\",\n    title = \"Média da SepalWidth por Espécie\",\n    legend = false)\n\n\n\n\n\n\n\n\nplot(box, barras, layout=(1, 2), size=(800, 400))\n\n\n\n\n\n\n\n\n\nusing DataFrames, StatsPlots\n\n# Agrupando por espécie e calculando a média do comprimento da pétala\nresumo = combine(groupby(iris, :Species), :SepalLength =&gt; mean =&gt; :MediaSepalLength)\n\n3×2 DataFrame\n Row │ Species     MediaSepalLength\n     │ Cat…        Float64\n─────┼──────────────────────────────\n   1 │ setosa                 5.006\n   2 │ versicolor             5.936\n   3 │ virginica              6.588\n\n\n# Gráfico de barras\nbar(resumo.Species, resumo.MediaSepalLength,\n    xlabel = \"Espécie\",\n    ylabel = \"Média do SepalLength\",\n    title = \"Média do Comprimento da Sépala por Espécie\",\n    legend = false)\n\n\n\n\n\n\n\n\nBoxplots são ótimos para visualizar a dispersão e identificar outliers, enquanto gráficos de barras ajudam a entender a frequência de categorias. Vamos agora agrupar os dados e visualizar mais de uma variável.\n\nusing DataFrames, StatsPlots, Statistics\n\n# Agrupando os dados e calculando suas medianas\n\ndf_bar = combine(groupby(iris, :Species),\n    :PetalWidth =&gt; median,\n    :PetalLength =&gt; median\n)\n\n3×3 DataFrame\n Row │ Species     PetalWidth_median  PetalLength_median\n     │ Cat…        Float64            Float64\n─────┼───────────────────────────────────────────────────\n   1 │ setosa                    0.2                1.5\n   2 │ versicolor                1.3                4.35\n   3 │ virginica                 2.0                5.55\n\n\n# Organizando os dados\n\ny = Matrix(select(df_bar, Not(:Species))) \n\n3×2 Matrix{Float64}:\n 0.2  1.5\n 1.3  4.35\n 2.0  5.55\n\nx = df_bar.Species                             \n\n3-element CategoricalArrays.CategoricalArray{String,1,UInt8}:\n \"setosa\"\n \"versicolor\"\n \"virginica\"\n\n\ngroupedbar(\n    x,\n    y,\n    bar_position = :dodge,\n    xlabel = \"Espécie\",\n    ylabel = \"Mediana\",\n    title = \"Mediana de PetalWidth e PetalLength por Espécie\",\n    label = [\"PetalWidth\" \"PetalLength\"],\n    bar_width = 0.6,\n    lw = 0,\n    framestyle = :box\n)\n\n\n\n\n\n\n\n\nAqui, separamos a mediana do comprimento e largura da pétala (PetalLength e PetalWidth) para cada espécie, assim conseguindo visualizar conjuntamente a medida dessas variáveis em diferentes grupos."
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#matriz-de-correlação-heatmap",
    "href": "Tutoriais/tutorial-eda.html#matriz-de-correlação-heatmap",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Matriz de Correlação (Heatmap)",
    "text": "Matriz de Correlação (Heatmap)\n\nusing StatsPlots\n\n# Criando uma matriz de correlação e visualizando com um heatmap\n\ndados_num = Matrix(iris[:, 1:4])\n\n150×4 Matrix{Float64}:\n 5.1  3.5  1.4  0.2\n 4.9  3.0  1.4  0.2\n 4.7  3.2  1.3  0.2\n 4.6  3.1  1.5  0.2\n 5.0  3.6  1.4  0.2\n 5.4  3.9  1.7  0.4\n 4.6  3.4  1.4  0.3\n 5.0  3.4  1.5  0.2\n 4.4  2.9  1.4  0.2\n 4.9  3.1  1.5  0.1\n ⋮              \n 6.9  3.1  5.1  2.3\n 5.8  2.7  5.1  1.9\n 6.8  3.2  5.9  2.3\n 6.7  3.3  5.7  2.5\n 6.7  3.0  5.2  2.3\n 6.3  2.5  5.0  1.9\n 6.5  3.0  5.2  2.0\n 6.2  3.4  5.4  2.3\n 5.9  3.0  5.1  1.8\n\ncor_matriz = cor(dados_num)\n\n4×4 Matrix{Float64}:\n  1.0       -0.11757    0.871754   0.817941\n -0.11757    1.0       -0.42844   -0.366126\n  0.871754  -0.42844    1.0        0.962865\n  0.817941  -0.366126   0.962865   1.0\n\nvar_nomes = names(iris)[1:4]\n\n4-element Vector{String}:\n \"SepalLength\"\n \"SepalWidth\"\n \"PetalLength\"\n \"PetalWidth\"\n\n\n# Plotando a matriz de correlação\n\nheatmap(\n    cor_matriz,\n    xticks=(1:4, var_nomes),\n    yticks=(1:4, var_nomes),\n    title=\"Matriz de Correlação\",\n    color=:blues,\n    size=(600, 500)\n)\n\n\n\n\n\n\n\n\nA matriz de correlação é uma ferramenta poderosa para entender a relação entre variáveis. O heatmap ajuda a visualizar essas correlações de forma intuitiva."
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#q-q-plot-normalidade",
    "href": "Tutoriais/tutorial-eda.html#q-q-plot-normalidade",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Q-Q Plot (Normalidade)",
    "text": "Q-Q Plot (Normalidade)\n\nusing Distributions, StatsPlots\n\n# Usando o pacote StatsPlots para criar um Q-Q plot\n\nqqplot(Normal(), iris.PetalLength,\n       xlabel=\"Quantis Teóricos\",\n       ylabel=\"Quantis Amostrais\",\n       title=\"Q-Q Plot de PetalLength\")\n\n\n\n\n\n\n\n\nQ-Q plots são úteis para verificar a normalidade dos dados. Se os pontos seguirem a linha reta, os dados possivelmente seguem uma distribuição normal. Nesse caso, vemos que a variável PetalLength não segue uma distribuição Normal."
  },
  {
    "objectID": "Tutoriais/tutorial-eda.html#série-temporal",
    "href": "Tutoriais/tutorial-eda.html#série-temporal",
    "title": "Introdução à Análise Exploratória de Dados (EDA) em Julia",
    "section": "Série Temporal",
    "text": "Série Temporal\nPor último, criamos uma série temporal simulada para ilustrar como visualizar dados ao longo do tempo. A função cumsum() é usada para calcular a soma acumulada (no nosso caso, acumular número aleatório de uma distribuição Normal padrão), e o gráfico mostra a evolução dos valores ao longo do ano.\n\nusing Dates\n\n# Gerando uma série temporal simulada\n\ndatas = Date(2024,1,1):Day(1):Date(2024,12,31)\n\nDate(\"2024-01-01\"):Day(1):Date(\"2024-12-31\")\n\nvalores = cumsum(randn(length(datas))) .+ 100\n\n366-element Vector{Float64}:\n  99.93356752809319\n 100.68920283747816\n 101.60107790420861\n 100.80867532750842\n 100.22443383684116\n  98.5038393366958\n  98.73218906091287\n  99.46750522556687\n  97.83974470691781\n  96.0199549308198\n   ⋮\n 101.50097700552809\n 100.33548507315055\n 100.31383058790584\n 101.02944569713357\n 101.40802609294452\n 100.68350893826006\n  99.82193264955082\n  97.79657769045133\n  97.80224894941702\n\n\n# Plotando a série temporal\n\nplot(datas, valores,\n     xlabel=\"Data\", ylabel=\"Valor\",\n     title=\"Série Temporal Simulada\",\n     linewidth=2, label=\"\")"
  },
  {
    "objectID": "tutoriais.html",
    "href": "tutoriais.html",
    "title": "Tutoriais",
    "section": "",
    "text": "Loops e Condicionais em Julia\n\n\n\nAplicação\n\n\nVisualização de Dados\n\n\n\nCondicionais e loops são estruturas fundamentais para o controle de fluxo em Julia. Enquanto as primeiras (if, elseif, else) permitem tomar decisões com base em condições…\n\n\n\nSarah Teixeira, Arthur Dionizio Martins da Silva\n\n\n30 de jul. de 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntrodução à Análise Exploratória de Dados (EDA) em Julia\n\n\n\nAplicação\n\n\nVisualização de Dados\n\n\n\nUm guia completo e prático sobre como realizar Análise Exploratória de Dados (EDA) em Julia. Explore desde estatísticas descritivas, manipulação de dados, visualizações com…\n\n\n\nArthur Dionizio, Henrique Velloso\n\n\n23 de mai. de 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGráficos em Julia: primeiros passos\n\n\n\nGráficos\n\n\n\nTão importante quanto desenvolver, implementar e aplicar modelos/metodologías é saber comunicar os resultados de forma clara e acessível para o público-alvo. E que melhor…\n\n\n\nNicole Fredericci, Carlos Trucíos\n\n\n23 de mai. de 2025\n\n\n\n\n\n\n\n\nNenhum item correspondente"
  },
  {
    "objectID": "equipe.html",
    "href": "equipe.html",
    "title": "Do Zero ao Julia",
    "section": "",
    "text": "Graduanda em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Matemática Aplicada e Computacional\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCoordenador\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduanda em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduanda em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDoutorando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduanda em Matemática Aplicada e Computacional\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDoutorando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\nNenhum item correspondente"
  },
  {
    "objectID": "equipe.html#equipe",
    "href": "equipe.html#equipe",
    "title": "Do Zero ao Julia",
    "section": "",
    "text": "Graduanda em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Matemática Aplicada e Computacional\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCoordenador\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduanda em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduanda em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDoutorando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduanda em Matemática Aplicada e Computacional\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDoutorando em Estatística\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduando em Estatística\n\n\n\n\n\n\n\nNenhum item correspondente"
  },
  {
    "objectID": "Tutoriais/graf_basico.html",
    "href": "Tutoriais/graf_basico.html",
    "title": "Gráficos em Julia: primeiros passos",
    "section": "",
    "text": "Lidar com diferentes linguagens de programação faz parte do dia a dia de pesquisadores, desenvolvedores e usuários finais nas áreas de STEM (Science, Technology, Engineering and Mathematics). No entanto, tão importante quanto desenvolver, implementar e aplicar modelos ou metodologias é saber comunicar os resultados de forma clara e acessível ao público-alvo. E nada melhor para isso do que visualizações didáticas e informativas.\nEmbora existam excelentes ferramentas para visualização de dados, como o ggplot2 do R e o seaborn do Python, é sempre útil saber como produzir gráficos, mesmo que básicos, diretamente na linguagem em que o código principal está sendo desenvolvido.\nNeste tutorial, você aprenderá a criar visualizações básicas em Julia utilizando o pacote Plots.jl, além de conhecer algumas bibliotecas auxiliares que tornam esse processo mais eficiente e versátil."
  },
  {
    "objectID": "Tutoriais/graf_basico.html#introdução",
    "href": "Tutoriais/graf_basico.html#introdução",
    "title": "Gráficos em Julia: primeiros passos",
    "section": "",
    "text": "Lidar com diferentes linguagens de programação faz parte do dia a dia de pesquisadores, desenvolvedores e usuários finais nas áreas de STEM (Science, Technology, Engineering and Mathematics). No entanto, tão importante quanto desenvolver, implementar e aplicar modelos ou metodologias é saber comunicar os resultados de forma clara e acessível ao público-alvo. E nada melhor para isso do que visualizações didáticas e informativas.\nEmbora existam excelentes ferramentas para visualização de dados, como o ggplot2 do R e o seaborn do Python, é sempre útil saber como produzir gráficos, mesmo que básicos, diretamente na linguagem em que o código principal está sendo desenvolvido.\nNeste tutorial, você aprenderá a criar visualizações básicas em Julia utilizando o pacote Plots.jl, além de conhecer algumas bibliotecas auxiliares que tornam esse processo mais eficiente e versátil."
  },
  {
    "objectID": "Tutoriais/graf_basico.html#como-criar-os-gráficos",
    "href": "Tutoriais/graf_basico.html#como-criar-os-gráficos",
    "title": "Gráficos em Julia: primeiros passos",
    "section": "Como criar os gráficos?",
    "text": "Como criar os gráficos?\nPara instalar o pacote principal e carregar seus comandos no ambiente, execute as seguintes linhas de código:\n\nPkg.add(\"Plots\")\nusing Plots\n\n\nLembre-se que precisamos apenas instalar o pacote uma única vez, mas chamá-lo em cada sessão que formos utilizá-lo.\n\n\nTambém utilizaremos os pacotes Distributions.jl e StatsPlots.jl para permitir a criação de gráficos com dados simulados e utilizar algumas distribuições de probabilidade. Para instalá-los e carregá-los, use:\n\n\nPkg.add(\"Distributions\")\nusing Distributions\n\nPkg.add(\"StatsPlots\")\nusing StatsPlots\n\n\nObservação: Uma boa prática em Julia é carregar os pacotes um por um, logo no início do script, seguindo a ordem alfabética. Isso torna o código mais organizado, facilita a leitura e a identificação de dependências. Por exemplo:\n\n\nusing Distributions\nusing Plots\nusing StatsPlots\n\n\nGráfico de Densidades\n\nUm dos gráficos mais básicos (e úteis) para visualização de dados é o gráfico de densidades. Vamos gerando um gráfico de densidade da distribuição Normal com média 0 e variância 1. Para isso, execute:\n\n\nplot(Normal(0,1), title = \"Distribuição Normal\", size = (800, 500))\n\n\n\n\n\n\n\n\nOutras distribuições contidas no pacote:\n\nBernoulli(\\(p\\))\nBeta(\\(\\alpha\\), \\(\\beta\\))\nBinomial(n, p)\nCauchy(\\(\\mu\\), \\(\\sigma\\))\nExponential(\\(\\theta\\))\nGamma(\\(\\alpha\\), \\(\\gamma\\))\nPoisson(\\(\\lambda\\))\nUniform(\\(a\\), \\(b\\))\nTDist(\\(\\nu\\))\n\n\nVocê pode conferir a documentação completa das funções no site oficial de Julia.\nA função plot() também pode ser utilizada para criar gráficos de linha ou de sequência:\n\n\nplot(randn(10), title = \"Gráfico de linha ou de sequência\", size = (800, 500))\n\n\n\n\n\n\n\n\n\n\nGráfico de Dispersão\n\nTambém é possível fazer um gráfico de dispersão (scatterplot) com o código abaixo. Neste exemplo, geramos valores em x de 0 a 10 com um espaçamento de 0,5 entre eles e calculamos y como o logaritmo de cada valor de x. Além de personalizar o título e o nome dos eixos, é possível controlar a exibição da legenda — o padrão é mostrar legend = auto, mas você pode ocultá-la com legend = false.\n\n\nx = 0:0.5:10\n\n0.0:0.5:10.0\n\ny = log.(x);\nscatter(x, y, title = \"Gráfico de Dispersão\", xlabel = \"x\", ylabel = \"log(x)\", legend = false)\n\n\n\n\n\n\n\n\n\nObservação: o operador \\(\\cdot\\) (dot), aplica a função \\(\\log()\\) a cada elemento do vetor x. O “;” evita que a variável y seja impressa (como aconteceu com a variável x).\n\n\n\nHistograma\n\nOutro recurso valioso na visualização de dados é o histograma, ideal para visualizar a distribuição de uma variável. Vamos construí-lo a partir da criação de uma variável x equivalente a 1000 números aleatórios de uma distribuição Normal(0, 1), executando o seguinte bloco:\n\n\nx = randn(1000);\nhistogram(x, title = \"Histograma\", color = :purple)\n\n\n\n\n\n\n\n\n\nNote que é possível customizar o número de intervalos (bins = 100, por exemplo) do seu histograma e modificar sua cor base. No exemplo abaixo, a cor é definida por nome (:purple), mas você também pode usar códigos hexadecimais — por exemplo, color = \"#800080\" produz o mesmo tom de roxo.\n\n\nhistogram(x, title = \"Histograma\", bins = 10, color = \"#111080\")\n\n\n\n\n\n\n\n\n\n\nBoxplot\n\nPara os estatísticos e cientistas de dados, o pacote Plots.jl oferece suporte ao conhecido boxplot, uma ferramenta eficaz para resumir estatísticas, ver assimetrias e identificar outliers. Ao executar o código abaixo, estaremos gerando dois vetores de 50 números aleatórios cada que, multiplicadas por 5, vão compor o conjunto de dados y.\n\n\ny = 5 * rand(50, 2);\nsize(y)\n\n(50, 2)\n\nboxplot(y, title = \"Boxplot\", color = [:darkorchid :darkorange])\n\n\n\n\n\n\n\n\n\nNote que para especificar cores manualmente, basta listar os nomes sem vírgula entre eles, tal qual no bloco acima. Esse detalhe é importante quando seus dados estão organizados em colunas no mesmo array. Abaixo veremos quando devemos incluir a vírgula.\n\n\n\nGráfico de Pizza\n\nTudo bem se você preferir os gráficos de pizza, eles ainda têm seu charme! 🎂 O bloco a seguir cria um gráfico de pizza utilizando a paleta de cores :tab10, que já vem disponível por padrão no pacote Plots.jl.\nVamos supor que os institutos IMECC, IG, IFGW e IFCH tenham, respectivamente, 700, 600, 500 e 470 alunos. Nosso objetivo é representar essas quantidades como porcentagens em um gráfico de pizza, considerando o total de alunos dos quatro institutos como 100%.\n\n\nz = [\"IMECC\", \"IG\", \"IFGW\", \"IFCH\"]\n\n4-element Vector{String}:\n \"IMECC\"\n \"IG\"\n \"IFGW\"\n \"IFCH\"\n\nalunos = [700, 600, 500, 470];\nw = 100 .* alunos ./ sum(alunos)\n\n4-element Vector{Float64}:\n 30.837004405286343\n 26.431718061674008\n 22.026431718061673\n 20.704845814977972\n\npie(z, w, title = \"Quantidade de alunos por instituto\", palette = :tab10)\n\n\n\n\n\n\n\n\nPara escolher manualmente as cores de cada fatia do gráfico de pizza, você pode usar uma lista de cores assim como no boxplot. Mas cuidado! Aqui os dados não foram gerados em conjunto, mas sim em dois vetores separados. Assim, para substituir o argumento palette, a vígula entre os nomes é necessária.\n\ncolor = [:darkorchid, :darkorange, :purple, :blue]\n\n\nLembre-se de definir uma cor para cada categoria presente no seu conjunto de dados, para evitar que as cores se repitam no gráfico.\n\n\n\nGráfico de Barras\nPara comparar valores entre diferentes grupos e categorias, podemos construir um gráfico de barras de estrutura semelhante ao seguinte:\n\nnum = [\"A\", \"B\", \"C\", \"D\", \"E\"]\n\n5-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n \"D\"\n \"E\"\n\nqnt = [100; 70; 100; 80; 60]\n\n5-element Vector{Int64}:\n 100\n  70\n 100\n  80\n  60\n\nbar(num, qnt, color = :seagreen)"
  },
  {
    "objectID": "Tutoriais/graf_basico.html#grids-e-combinações",
    "href": "Tutoriais/graf_basico.html#grids-e-combinações",
    "title": "Gráficos em Julia: primeiros passos",
    "section": "Grids e Combinações",
    "text": "Grids e Combinações\n\nUma ferramenta bastante utilizada na visualização de dados é a junção de gráficos distintos na mesma imagem para facilitar a comparação, ou sobrepor múltiplas curvas em um único gráfico para contrastá-las no mesmo plano. Se você deseja criar o famoso grid (também chamado de malha gráfica), Julia oferece soluções práticas.\n\n\nh = range(0, 10, length = 100);\nk = @. log(h);\nj = @. exp(h);\nplot(h, [k j], layout = (2, 1), legend = false, color = :green)\n\n\n\n\n\n\n\n\n\nNa figura acima criamos um vetor h com 100 valores uniformemente espaçados entre 0 e 10, um vetor k correspondente ao logaritmo dos elementos de h, e j ao exponencial dos mesmos elementos. O argumento layout define a disposição dos gráficos na figura, no qual o primeiro número indica o número de linhas e o segundo o número de colunas do grid. Agora, vamos combinar essas mesmas informações em um único gráfico, ajustando j para que sua escala fique mais próxima à de k.\n\n\nj2 = @. exp(h)/5000;\n\nplot(h, k, label = \"log\", color = :green)\n\n\n\n\n\n\n\nplot!(h, j2, label = \"exp/5000\", color = :steelblue, ls = :dash)\n\n\n\n\n\n\n\n\n\nNote que além de ocultar ou exibir a legenda, é possível personalizar os rótulos (labels) do seu gráfico e escolher diferentes estilos para as linhas das curvas."
  },
  {
    "objectID": "Tutoriais/graf_basico.html#personalização-de-atributos",
    "href": "Tutoriais/graf_basico.html#personalização-de-atributos",
    "title": "Gráficos em Julia: primeiros passos",
    "section": "Personalização de atributos",
    "text": "Personalização de atributos\n\nCaso nenhuma das customizações mostradas até agora seja suficiente para ilustrar seus dados de forma adequada, segue-se uma gama de opções adicionais para ajustar os atributos visuais do gráfico.\n\n\nCores e Paletas\n\nPara explorar as cores nomeadas disponíveis na base do Julia e seus códigos RGB (uma tripla que representa a composição de vermelho, verde e azul), você pode acessar a lista oficial clicando em cores. Se você quiser diversificar as opções de paletas disponíveis, o pacote ColorSchemes pode ser adicionado à sua biblioteca:\n\n\nPkg.add(\"ColorSchemes\")\nusing ColorSchemes\n\n\nO pacote conta com opções de paletas para usuários com Deficiência de Visão de Cores!\n\n\n\nEstilo da linha\nOs seguintes estilos podem ser determinados no argumento ls (line style) para customizar as curvas do gráfico:\n\n:solid      #linha sólida\n:dash       #tracejado\n:dot        #pontos\n:dashdot    #tracejado seguido de um ponto\n:dashdotdot #tracejado seguido de dois pontos"
  },
  {
    "objectID": "Tutoriais/graf_basico.html#como-salvar-o-gráfico",
    "href": "Tutoriais/graf_basico.html#como-salvar-o-gráfico",
    "title": "Gráficos em Julia: primeiros passos",
    "section": "Como salvar o gráfico?",
    "text": "Como salvar o gráfico?\nPor fim, você pode salvar o gráfico no diretório do seu projeto utilizando o seguinte comando:\n\np = plot(x, y)\nsavefig(p,\"nome.png\")\n\nCaso você não tenha atribuído o gráfico a um objeto p, é possível salvar a figura imediatamente após a criação do gráfico, omitindo o objeto.\n\nplot(x, y)\nsavefig(\"meu_gráfico.png\")\n\nSe fizer alterações no gráfico e quiser atualizar a imagem salva, basta executar novamente o comando savefig com o mesmo nome. A figura anterior será substituída pela versão atualizada no seu diretório.\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "meetup.html",
    "href": "meetup.html",
    "title": "Meetup",
    "section": "",
    "text": "Os meetups acontecem toda terceira quinta-feira do mês, nas dependências do IMECC/UNICAMP. O ingresso é gratuito e aberto ao público (mas precisa de inscrição). Para participar, inscreva-se aqui.\n\n\n\n\n\n\nÉ gratis, é sobre Julia e é no IMECC/UNICAMP!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Do Zero ao Julia",
    "section": "",
    "text": "Descubra e explore as vantagens da linguagem de programação Julia: uma poderosa ferramenta para o ensino, a implementação e o desenvolvimento de métodos estatísticos e de ciência de dados.\n\n\n\n\n\n\n\n\n\n\n\nDescubra as vantagens e dicas de Julia\n\nBlog\n\n\n\n\n\n\n\n\n\nExplore diversos tópicos em Julia\n\nTutoriais\n\n\n\n\n\n\n\n\n\nConheça casos de sucesso e amplie seu networking.\n\nMeetup"
  },
  {
    "objectID": "Blog/Matrizes.html",
    "href": "Blog/Matrizes.html",
    "title": "Matrizes em Julia",
    "section": "",
    "text": "Matrizes são estruturas matemáticas em formato tabular, organizadas em linhas e colunas, com operações bem definidas como adição, subtração, multiplicação e transposição. De maneira intuitiva, podem ser vistas como uma extensão bidimensional dos vetores. São amplamente utilizadas para armazenar e manipular dados, desempenhando papel central em estatística, econometria e aprendizado de máquina.\nNeste post, você aprenderá a criar matrizes, acessar elementos, realizar operações e explorar suas principais propriedades. Também será apresentado, de forma breve, como utilizar o pacote LinearAlgebra.jl para funções relacionadas à álgebra linear e cláculo matricial."
  },
  {
    "objectID": "Blog/Matrizes.html#introdução---o-que-são-matrizes",
    "href": "Blog/Matrizes.html#introdução---o-que-são-matrizes",
    "title": "Matrizes em Julia",
    "section": "",
    "text": "Matrizes são estruturas matemáticas em formato tabular, organizadas em linhas e colunas, com operações bem definidas como adição, subtração, multiplicação e transposição. De maneira intuitiva, podem ser vistas como uma extensão bidimensional dos vetores. São amplamente utilizadas para armazenar e manipular dados, desempenhando papel central em estatística, econometria e aprendizado de máquina.\nNeste post, você aprenderá a criar matrizes, acessar elementos, realizar operações e explorar suas principais propriedades. Também será apresentado, de forma breve, como utilizar o pacote LinearAlgebra.jl para funções relacionadas à álgebra linear e cláculo matricial."
  },
  {
    "objectID": "Blog/Matrizes.html#criando-matrizes",
    "href": "Blog/Matrizes.html#criando-matrizes",
    "title": "Matrizes em Julia",
    "section": "Criando Matrizes",
    "text": "Criando Matrizes\n\nEm Julia, a notação tradicional para matrizes utiliza colchetes [ ]. Dentro deles, o espaço ( ) separa as colunas, o ponto e vírgula (;) separa as linhas, e o triplo ponto e vírgula (;;;) adiciona uma nova dimensão, permitindo criar arrays tridimensionais a partir de matrizes bidimensionais.\n\n\n# Vetor → array 1D (uma dimensão)\nv = [1 2 3 4 5 6]\n\n1×6 Matrix{Int64}:\n 1  2  3  4  5  6\n\n# Matriz → array 2D (linhas e colunas)\nm = [1 2 3; 4 5 6]\n\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n# Array → array 3D (pilha de matrizes 2D)\nM = [1 2 3; 4 5 6; 7 8 9 ;;; 10 11 12; 13 14 15; 16 17 18]\n\n3×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  2  3\n 4  5  6\n 7  8  9\n\n[:, :, 2] =\n 10  11  12\n 13  14  15\n 16  17  18\n\n\n\nAlém de escrever manualmente com colchetes, Julia oferece funções que facilitam a criação de matrizes com formatos específicos ou preenchimento automático. Algumas das mais comuns são:\n\nzeros(m, n): cria uma matriz \\(m \\times n\\) preenchida com zeros.\nones(m, n): gera uma matriz \\(m \\times n\\) preenchida com uns.\nrand(m, n): cria uma matriz \\(m \\times n\\) com valores aleatórios entre 0 e 1.\nreshape(v, m, n): transforma um vetor v ou matriz existente em uma nova forma \\(m \\times n\\) .\nMatrix(...): converte estruturas em matriz; por exemplo, Matrix(I, m, m) cria uma matriz identidade \\(m \\times n\\) .\n\n\n\nA = zeros(2, 3)\n\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\nB = ones(3, 2)\n\n3×2 Matrix{Float64}:\n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n\nC = rand(2, 2)\n\n2×2 Matrix{Float64}:\n 0.576186  0.0233843\n 0.481981  0.729087\n\n# Transformando um vetor em uma matriz 2x3\nv = 1:6\n\n1:6\n\nD = reshape(v, 2, 3)\n\n2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:\n 1  3  5\n 2  4  6\n\n# Matriz identidade 4x4 com elementos inteiros\nE = Matrix{Int64}(I, 4, 4)\n\n4×4 Matrix{Int64}:\n 1  0  0  0\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n\n# Matriz 3x2 criada com expressão compacta (com base em i + j)\nF = [i + j for i in 1:3, j in 1:2]\n\n3×2 Matrix{Int64}:\n 2  3\n 3  4\n 4  5"
  },
  {
    "objectID": "Blog/Matrizes.html#indexação-e-acesso-a-elementos",
    "href": "Blog/Matrizes.html#indexação-e-acesso-a-elementos",
    "title": "Matrizes em Julia",
    "section": "Indexação e Acesso a Elementos",
    "text": "Indexação e Acesso a Elementos\n\nAssim como em R, a indexação em Julia é 1-based, ou seja, a contagem começa a partir de 1 — diferente do Python, que é 0-based.\nPara acessar os elementos de uma matriz, usamos a notação matriz[linha, coluna]. Também é possível acessar linhas e colunas inteiras ou selecionar subconjuntos da matriz utilizando o operador de dois-pontos (:), que indica “todos os elementos” naquela dimensão.\n\n\n# Cria uma matriz 3x3 com valores de 1 a 9\nm1 = reshape(1:9, 3, 3)\n\n3×3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64:\n 1  4  7\n 2  5  8\n 3  6  9\n\n# Acessa o elemento da 1ª linha, 2ª coluna \nm1[1, 2]\n\n4\n\n# Acessa o elemento da 3ª linha, 3ª coluna \nm1[3, 3]\n\n9\n\n# Acessa toda a 2ª linha \nm1[2, :]\n\n3-element Vector{Int64}:\n 2\n 5\n 8\n\n# Acessa toda a 1ª coluna \nm1[:, 1]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n# Acessa um bloco 2x2 \nm1[1:2, 2:3]\n\n2×2 Matrix{Int64}:\n 4  7\n 5  8"
  },
  {
    "objectID": "Blog/Matrizes.html#operações",
    "href": "Blog/Matrizes.html#operações",
    "title": "Matrizes em Julia",
    "section": "Operações",
    "text": "Operações\n\nJulia possibilita a execução de operações matriciais de forma simples e direta.\n\n\nAdição e Subtração\n\nG = [1 2; 3 4]\n\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nH = [5 6; 7 8]\n\n2×2 Matrix{Int64}:\n 5  6\n 7  8\n\nG + H  \n\n2×2 Matrix{Int64}:\n  6   8\n 10  12\n\nG - H  \n\n2×2 Matrix{Int64}:\n -4  -4\n -4  -4\n\n\n\n\nMultiplicação\n\nExistem dois tipos de multiplicação em Julia:\n\n*: Multiplicação matricial.\n.*: Multiplicação elemento a elemento.\n\n\n\nG * H\n\n2×2 Matrix{Int64}:\n 19  22\n 43  50\n\nG * 2\n\n2×2 Matrix{Int64}:\n 2  4\n 6  8\n\nG .* H\n\n2×2 Matrix{Int64}:\n  5  12\n 21  32\n\n\n\n\nTransposição\n\nCalcular a transposta de uma matriz com Julia pode ser feito de duas formas: utilizando transpose() ou utilizando o operador '. Contudo, no caso da matriz conter números complexos, ' calculará a conjugada complexa.\n\n\ntranspose(G)\n\n2×2 transpose(::Matrix{Int64}) with eltype Int64:\n 1  3\n 2  4\n\nG'\n\n2×2 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  3\n 2  4"
  },
  {
    "objectID": "Blog/Matrizes.html#propriedades-e-funções-úteis",
    "href": "Blog/Matrizes.html#propriedades-e-funções-úteis",
    "title": "Matrizes em Julia",
    "section": "Propriedades e Funções Úteis",
    "text": "Propriedades e Funções Úteis\n\nUsando o pacote LinearAlgebra.jl, que já faz parte da instalação padrão do Julia, podemos acessar diversas propriedades e aplicar funções úteis às matrizes. Antes de utilizá-las, é necessário carregar o pacote no ambiente:\n\n\nusing LinearAlgebra\n\n\nPropriedades Básicas\n\n\nsize(m): retorna uma tupla com o número de linhas e colunas.\nlength(m): indica o total de elementos presentes na matriz.\neltype(m): retorna o tipo dos elementos da matriz.\nndims(m): retorna o número de dimensões (normalmente 2, no caso de matrizes).\n\n\n\n# Criando uma matriz 2x2\nJ = [1 2; 3 4]\n\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nsize(J)\n\n(2, 2)\n\nlength(J)\n\n4\n\neltype(J)\n\nInt64\n\nndims(J)\n\n2\n\n\n\n\nOperações com Álgebra Linear\n\n\ndet(m): calcula o determinante da matriz.\ninv(m): retorna a matriz inversa, se ela existir.\nrank(m): retorna o posto da matriz (número de linhas/colunas linearmente independentes).\neigvals(m): obtém os autovalores da matriz.\neigvecs(m): obtém os autovetores correspondentes.\ntr(m): calcula o traço da matriz (soma dos elementos da diagonal principal).\n\n\n\n# Criando uma matriz 2x2\nJ = [1 2; 3 4]\n\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\ndet(J)\n\n-2.0\n\ninv(J)\n\n2×2 Matrix{Float64}:\n -2.0   1.0\n  1.5  -0.5\n\nrank(J)\n\n2\n\neigvals(J)\n\n2-element Vector{Float64}:\n -0.3722813232690143\n  5.372281323269014\n\neigvecs(J)\n\n2×2 Matrix{Float64}:\n -0.824565  -0.415974\n  0.565767  -0.909377\n\ntr(J)\n\n5"
  },
  {
    "objectID": "Blog/Matrizes.html#conclusão",
    "href": "Blog/Matrizes.html#conclusão",
    "title": "Matrizes em Julia",
    "section": "Conclusão",
    "text": "Conclusão\n\nEste foi um guia básico sobre o uso de matrizes em Julia, abordando desde a criação até operações fundamentais e funções úteis com o pacote LinearAlgebra.jl. Por serem estruturas essenciais em inúmeras áreas científicas e computacionais, Julia oferece ferramentas poderosas e eficientes para manipular matrizes de forma intuitiva.\nNos próximos posts, exploraremos tópicos mais avançados, como sistemas lineares, decomposições matriciais e aplicações de matrizes em Machine Learning. Até lá!\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "",
    "text": "A Álgebra Linear constitui a espinha dorsal de diversas áreas do conhecimento científico e tecnológico, como análise de dados, processamento de sinais, otimização, estatística multivariada, machine learning e mecânica quântica. Computacionaomente, uma linguagem eficiente como Julia oferece não apenas sintaxe intuitiva, mas também desempenho comparável a linguagens de baixo nível. O pacote LinearAlgebra.jl, integrante da biblioteca padrão, disponibiliza uma ampla variedade de funcionalidades para a manipulação eficiente de vetores, matrizes, resolução de sistemas lineares e decomposições matriciais. Neste post, exploraremos o uso do módulo, abordando desde operações elementares até técnicas mais sofisticadas, como decomposições matriciais, projeções e diagonalização."
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html#introdução",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html#introdução",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "",
    "text": "A Álgebra Linear constitui a espinha dorsal de diversas áreas do conhecimento científico e tecnológico, como análise de dados, processamento de sinais, otimização, estatística multivariada, machine learning e mecânica quântica. Computacionaomente, uma linguagem eficiente como Julia oferece não apenas sintaxe intuitiva, mas também desempenho comparável a linguagens de baixo nível. O pacote LinearAlgebra.jl, integrante da biblioteca padrão, disponibiliza uma ampla variedade de funcionalidades para a manipulação eficiente de vetores, matrizes, resolução de sistemas lineares e decomposições matriciais. Neste post, exploraremos o uso do módulo, abordando desde operações elementares até técnicas mais sofisticadas, como decomposições matriciais, projeções e diagonalização."
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html#carregando-o-pacote",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html#carregando-o-pacote",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "Carregando o pacote",
    "text": "Carregando o pacote\nO pacote LinearAlgebra.jl já está incluído na instalação padrão do Julia. Para utilizá-lo, basta importá-lo com o comando:\n\nusing LinearAlgebra\n\nUtilizaremos também o pacote Random para gerar matrizes aleatórias nos exemplos seguintes:\n\nusing Random"
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html#operações-elementares-com-matrizes-e-vetores",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html#operações-elementares-com-matrizes-e-vetores",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "Operações elementares com matrizes e vetores",
    "text": "Operações elementares com matrizes e vetores\n\nIniciamos com a criação de vetores e matrizes, bem como a execução de operações fundamentais, como multiplicação, produto escalar e cálculo de normas:\n\n\nA = [1 2; 3 4]      # matriz 2x2\n\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nv = [1, 2]          # vetor coluna\n\n2-element Vector{Int64}:\n 1\n 2\n\n\nA * v               # multiplicação matriz-vetor\n\n2-element Vector{Int64}:\n  5\n 11\n\ndot(v, v)           # produto escalar\n\n5\n\nnorm(v)             # norma (magnitude) do vetor\n\n2.23606797749979"
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html#operações-com-matrizes",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html#operações-com-matrizes",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "Operações com matrizes",
    "text": "Operações com matrizes\n\ntranspose(A)        # transposta\n\n2×2 transpose(::Matrix{Int64}) with eltype Int64:\n 1  3\n 2  4\n\ninv(A)              # inversa\n\n2×2 Matrix{Float64}:\n -2.0   1.0\n  1.5  -0.5\n\ndet(A)              # determinante\n\n-2.0\n\ntr(A)               # traço da matriz\n\n5\n\nrank(A)             # posto\n\n2"
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html#resolvendo-sistemas-lineares",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html#resolvendo-sistemas-lineares",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "Resolvendo sistemas lineares",
    "text": "Resolvendo sistemas lineares\n\nEm Julia, a forma mais eficiente de resolver um sistema linear (Ax = b) consiste no uso do operador barra invertida \\, que seleciona automaticamente o algoritmo numérico apropriado com base nas características da matriz:\n\n\nA = [3 1; 1 2]\n\n2×2 Matrix{Int64}:\n 3  1\n 1  2\n\nb = [9, 8]\n\n2-element Vector{Int64}:\n 9\n 8\n\nx = A \\ b           # solução do sistema\n\n2-element Vector{Float64}:\n 2.0\n 3.0"
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html#decomposições-matriciais",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html#decomposições-matriciais",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "Decomposições matriciais",
    "text": "Decomposições matriciais\n\nDecomposições permitem entender a estrutura interna de uma matriz, facilitando a resolução de sistemas, o cálculo de autovalores, compressões e outras aplicações numéricas. A seguir, exploramos as principais disponíveis no LinearAlgebra.jl:\n\n\nLU (Fatoração de matrizes quadradas)\n\nlu(A)\n\nLU{Float64, Matrix{Float64}, Vector{Int64}}\nL factor:\n2×2 Matrix{Float64}:\n 1.0       0.0\n 0.333333  1.0\nU factor:\n2×2 Matrix{Float64}:\n 3.0  1.0\n 0.0  1.66667\n\n\n\n\nQR (Bastante usada em regressão linear)\n\nqr(A)\n\nLinearAlgebra.QRCompactWY{Float64, Matrix{Float64}, Matrix{Float64}}\nQ factor: 2×2 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}, Matrix{Float64}}\nR factor:\n2×2 Matrix{Float64}:\n -3.16228  -1.58114\n  0.0       1.58114\n\n\n\n\nSVD (Decomposição em valores singulares)\n\nsvd(A)\n\nSVD{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nU factor:\n2×2 Matrix{Float64}:\n -0.850651  -0.525731\n -0.525731   0.850651\nsingular values:\n2-element Vector{Float64}:\n 3.6180339887498953\n 1.3819660112501049\nVt factor:\n2×2 Matrix{Float64}:\n -0.850651  -0.525731\n -0.525731   0.850651\n\n\n\n\nAutovalores e autovetores\n\neigvals(A)\n\n2-element Vector{Float64}:\n 1.381966011250105\n 3.618033988749895\n\neigvecs(A)\n\n2×2 Matrix{Float64}:\n  0.525731  -0.850651\n -0.850651  -0.525731"
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html#álgebra-linear-com-matrizes-aleatórias-usando-random",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html#álgebra-linear-com-matrizes-aleatórias-usando-random",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "Álgebra linear com matrizes aleatórias usando random",
    "text": "Álgebra linear com matrizes aleatórias usando random\n\nA geração de matrizes aleatórias permite simulações e testes práticos. Veja exemplos de operações úteis com matrizes densas:\n\n\nRandom.seed!(123)\n\nTaskLocalRNG()\n\nM = rand(3,3)      # matriz 3x3 com elementos aleatórios\n\n3×3 Matrix{Float64}:\n 0.9063    0.512083  0.427328\n 0.443494  0.253849  0.867547\n 0.745673  0.334152  0.581912\n\n\nnorm(M)            # norma de Frobenius\n\n1.8128125670179398\n\nI                  # matriz identidade\n\nUniformScaling{Bool}\ntrue*I\n\nM'                 # transposta conjugada\n\n3×3 adjoint(::Matrix{Float64}) with eltype Float64:\n 0.9063    0.443494  0.745673\n 0.512083  0.253849  0.334152\n 0.427328  0.867547  0.581912"
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html#diagonalização-de-matrizes",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html#diagonalização-de-matrizes",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "Diagonalização de matrizes",
    "text": "Diagonalização de matrizes\n\nUma matriz \\(A\\) é diagonalizável se existe uma matriz invertível \\(P\\) tal que \\(D = P^{-1} A P\\) seja diagonalizável.\n\n\nV = eigvecs(A)\n\n2×2 Matrix{Float64}:\n  0.525731  -0.850651\n -0.850651  -0.525731\n\nD = Diagonal(eigvals(A))\n\n2×2 Diagonal{Float64, Vector{Float64}}:\n 1.38197   ⋅ \n  ⋅       3.61803\n\nP = V\n\n2×2 Matrix{Float64}:\n  0.525731  -0.850651\n -0.850651  -0.525731\n\nP_inv = inv(P)\n\n2×2 Matrix{Float64}:\n  0.525731  -0.850651\n -0.850651  -0.525731\n\nP_inv * A * P ≈ D   # Verificação\n\ntrue\n\n\n\n\nObs.: Nem toda matriz é diagonalizável. Em aplicações práticas, a diagonalização é útil, por exemplo, para calcular potências de matrizes com eficiência."
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html#espaços-vetorias-e-projeções-ortogonais",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html#espaços-vetorias-e-projeções-ortogonais",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "Espaços vetorias e projeções ortogonais",
    "text": "Espaços vetorias e projeções ortogonais\n\nDada uma matriz \\(A\\), seus espaços fundamentais (imagem, núcleo) são essenciais para entender soluções de sistemas e dimensões associadas:\n\n\nnullspace(A)                 # espaço nulo (ker A)\n\n2×0 Matrix{Float64}\n\ncolspace = A[:, :]           # espaço coluna (imagem)\n\n2×2 Matrix{Int64}:\n 3  1\n 1  2\n\n\nnullspace([1 2 3; 2 4 6] )   # Base não trivial\n\n3×2 Matrix{Float64}:\n -0.935937   -0.229334\n  0.342011   -0.772861\n  0.0839716   0.591685\n\n\nE para projetar um vetor \\(b\\) no subespaço gerado pelas colunas de \\(A\\):\n\nproj = A * (A \\ b)\n\n2-element Vector{Float64}:\n 9.0\n 8.0\n\n\nEssa projeção ortogonal é usada em mínimos quadrados."
  },
  {
    "objectID": "Blog/Álgebra linear com LinearAlgebra.jl.html#conclusão",
    "href": "Blog/Álgebra linear com LinearAlgebra.jl.html#conclusão",
    "title": "Álgebra linear com LinearAlgebra.jl",
    "section": "Conclusão",
    "text": "Conclusão\n\nO pacote LinearAlgebra.jl oferece ferramentas robustas, rápidas e versáteis para o tratamento de problemas de álgebra linear em Julia. A combinação com bibliotecas de visualização como Plots.jl, já mostradas aqui no blog, e outras de aprendizado de máquina torna sua utilização ainda mais poderosa em aplicações científicas e tecnológicas. Sua implementação é baseada em bibliotecas otimizadas como BLAS e LAPACK, garantindo um desempenho extremamente competitivo. O estudo da Álgebra Linear computacionalmente não apenas facilita a resolução de problemas práticos como também aprofunda a intuição matemática sobre transformações lineares, autovalores, espaços vetoriais e estabilidade numérica. Para consolidar seus conhecimentos, recomenda-se também a leitura da documentação oficial e a prática com aplicações reais em modelagem, machine learning e análise de dados.\n\n\nBiblioteca padrão de Álgebra Linear numérica em Julia\nDocumentação oficial do pacote LinearAlgebra.jl :::\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/markdown_pluto.html",
    "href": "Blog/markdown_pluto.html",
    "title": "Como criar relatórios dinâmicos com Julia e Pluto",
    "section": "",
    "text": "Ao programar, é essencial manter uma documentação clara e com boa visualização, especialmente ao apresentar nosso trabalho para outras pessoas. Para isso, muitas linguagens oferecem compatibilidade com Markdown, uma ferramenta que permite combinar texto e código de maneira dinâmica, tornando a criação de relatórios muito mais prática.\nFelizmente, ao programar em Julia, é possível utilizar Markdown diretamente com o auxílio do pacote Pluto, que integra esses recursos de maneira simples e eficiente."
  },
  {
    "objectID": "Blog/markdown_pluto.html#introdução",
    "href": "Blog/markdown_pluto.html#introdução",
    "title": "Como criar relatórios dinâmicos com Julia e Pluto",
    "section": "",
    "text": "Ao programar, é essencial manter uma documentação clara e com boa visualização, especialmente ao apresentar nosso trabalho para outras pessoas. Para isso, muitas linguagens oferecem compatibilidade com Markdown, uma ferramenta que permite combinar texto e código de maneira dinâmica, tornando a criação de relatórios muito mais prática.\nFelizmente, ao programar em Julia, é possível utilizar Markdown diretamente com o auxílio do pacote Pluto, que integra esses recursos de maneira simples e eficiente."
  },
  {
    "objectID": "Blog/markdown_pluto.html#instalação-do-pluto",
    "href": "Blog/markdown_pluto.html#instalação-do-pluto",
    "title": "Como criar relatórios dinâmicos com Julia e Pluto",
    "section": "Instalação do Pluto",
    "text": "Instalação do Pluto\nEm primeiro lugar, é necessário que o Julia esteja instalado. A partir disso, é necessário abrir o programa e digitar o seguinte código:\nusing Pkg\nPkg.add(\"Pluto\")"
  },
  {
    "objectID": "Blog/markdown_pluto.html#conhecendo-o-pluto",
    "href": "Blog/markdown_pluto.html#conhecendo-o-pluto",
    "title": "Como criar relatórios dinâmicos com Julia e Pluto",
    "section": "Conhecendo o Pluto",
    "text": "Conhecendo o Pluto\nCom o pacote instalado, já podemos começar a usar o Pluto. Para isso, abrimos o Julia e digitamos o seguinte código, que será utilizado todas as vezes que quisermos acessá-lo.\nusing Pluto\nPluto.run()\nApós rodar o código, o Pluto será carregado e a seguinte tela estará aberta no seu navegador padrão:\n\n\n\nTela Inicial Pluto\n\n\nEstarão destacados os últimos arquivos acessados e, caso seja a primeira vez, constarão alguns exemplos. A partir de Open a notebook, podemos acessar as pastas do nosso computador e escolher o arquivo que desejamos abrir.\nNo caso, vamos criar um arquivo do zero clicando em Create a new notebook. Após a criação, esta é a tela inicial que será aberta:\n\n\n\nAqruivo Vazio no Pluto\n\n\nCom isso, a partir dessa página, podemos adicionar os textos e códigos utilizando os cell code (célula de código), os quais podemos adicionar clicando nos “mais” que aparecem ao aproximar o cursor. Para ser um código, basta programar de forma normal, mas para inserir textos, é necessário que esteja no formato md”seu_texto”.\nPara ilustrar o básico do Pluto, vamos realizar algumas simples tarefas:\n\nAdicionar o título “Aprendendo Julia Markdown” (Para aumentar o tamanho do texto, utilizaremos #);\nInserir o texto: “O código abaixo cria uma função que, dados dois números reais, computa a soma deles:”;\nInserir o código da função;\nInserir o texto: “Para testar a função, vamos utilizar como argumentos 2 e 3.”;\nAvaliar nossa função com os valores determinados.\n\nPortanto, agora nós temos:\n\n\n\nAqruivo no Pluto com Tarefas Propostas\n\n\nVale destacar que as saídas de cada célula aparecem logo acima dela. Além disso, podemos ocultar os códigos que não queremos, a fim de deixar a visualização mais limpa, clicando no ícone de olho que aparece ao passar o cursor em um cell code. Assim, obtemos por fim:\n\n\n\nVersão Final do Código com Pluto\n\n\nPortanto, utilizando o Pluto, conseguimos criar relatórios dinâmicos combinando texto e código de forma muito prática. Essa integração facilita tanto o desenvolvimento quanto a apresentação dos conteúdos, tornando o processo mais claro, organizado e interativo. Além disso, é possível explorar uma variedade de recursos adicionais, como tabelas, imagens, fórmulas matemáticas em LaTeX, gráficos, e muito mais.\nCom essas possibilidades, o Pluto se torna uma ferramenta extremamente útil para documentação de projetos, produção de material didático, análise de dados e compartilhamento de ideias de forma acessível e visualmente atrativa.\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/Velocidade de Processamento.html",
    "href": "Blog/Velocidade de Processamento.html",
    "title": "Velocidade de Processamento: R vs Julia vs Python",
    "section": "",
    "text": "Em uma linguagem interpretada, o código é processado linha a linha por um interpretador, o que facilita a execução de testes rápidos, execução de trechos isolados e depuração (mas reduz a velocidade em operações intensivas). Já em linguagens com compilação Just-In-Time (JIT), o interpretador compila trechos do código em linguagem de máquina durante a execução, em vez de interpretar linha a linha o tempo todo, permitindo um desempenho próximo a linguagens compiladas (especialmente em loops e cálculos intensivos). E quando se procura uma linguagem de programação para análise de dados ou computação científica, a velocidade de processamento pode influenciar bastante a escolha. Neste post, comparamos três linguagens populares — R, Julia e Python — analisando seu desempenho em uma tarefa computacionalmente intensiva."
  },
  {
    "objectID": "Blog/Velocidade de Processamento.html#introdução",
    "href": "Blog/Velocidade de Processamento.html#introdução",
    "title": "Velocidade de Processamento: R vs Julia vs Python",
    "section": "",
    "text": "Em uma linguagem interpretada, o código é processado linha a linha por um interpretador, o que facilita a execução de testes rápidos, execução de trechos isolados e depuração (mas reduz a velocidade em operações intensivas). Já em linguagens com compilação Just-In-Time (JIT), o interpretador compila trechos do código em linguagem de máquina durante a execução, em vez de interpretar linha a linha o tempo todo, permitindo um desempenho próximo a linguagens compiladas (especialmente em loops e cálculos intensivos). E quando se procura uma linguagem de programação para análise de dados ou computação científica, a velocidade de processamento pode influenciar bastante a escolha. Neste post, comparamos três linguagens populares — R, Julia e Python — analisando seu desempenho em uma tarefa computacionalmente intensiva."
  },
  {
    "objectID": "Blog/Velocidade de Processamento.html#por-que-a-velocidade-difere",
    "href": "Blog/Velocidade de Processamento.html#por-que-a-velocidade-difere",
    "title": "Velocidade de Processamento: R vs Julia vs Python",
    "section": "Por que a velocidade difere?",
    "text": "Por que a velocidade difere?\n\n\nPython: Linguagem interpretada e dinâmica, o que geralmente a torna mais lenta. No entanto, bibliotecas como NumPy e Pandas usam implementações em C e Fortran, permitindo um bom desempenho em operações numéricas.\nR: Também é interpretada e foi criada para atender ao público da estatística. Loops puros são lentos, mas funções vetorizadas e pacotes como data.table e dplyr oferecem bom desempenho.\nJulia: Projetada para alta performance, atinge velocidades próximas às de C e Fortran sem depender de bibliotecas externas, graças à sua compilação JIT. Vale notar que Python e R também podem alcançar desempenho semelhante usando ferramentas que compilam partes do código em C, como Cython (uma extensão para Python) e Rcpp (um pacote para R)."
  },
  {
    "objectID": "Blog/Velocidade de Processamento.html#exemplo-prático-cálculo-de-fibonacci",
    "href": "Blog/Velocidade de Processamento.html#exemplo-prático-cálculo-de-fibonacci",
    "title": "Velocidade de Processamento: R vs Julia vs Python",
    "section": "Exemplo Prático: Cálculo de Fibonacci",
    "text": "Exemplo Prático: Cálculo de Fibonacci\n\nPara evidenciar a diferença de desempenho bruto entre as três linguagens, implementamos uma função recursiva de Fibonacci (propositalmente ineficiente), com o objetivo de testar a velocidade de processamento. Os resultados apresentados foram obtidos em um MacBook equipado com Apple M3 Pro e 18 GB de RAM.\n\nR\n\nfib &lt;- function(n) {\n    if (n &lt;= 1) {\n        return(n)\n    } else {\n        return(fib(n-1) + fib(n-2))\n    }\n}\n\n\n\n\nstart &lt;- Sys.time()\nresult &lt;- fib(30)\nend &lt;- Sys.time()\n\nprint(paste(\"Resultado:\", result))\n\n[1] \"Resultado: 832040\"\n\nprint(paste(\"Tempo R:\", end - start))\n\n[1] \"Tempo R: 0.345631837844849\"\n\n\n\n\nstart &lt;- Sys.time()\nresult &lt;- fib(40)\nend &lt;- Sys.time()\n\nprint(paste(\"Resultado:\", result))\n\n[1] \"Resultado: 102334155\"\n\nprint(paste(\"Tempo R:\", end - start))\n\n[1] \"Tempo R: 40.7386250495911\"\n\n\n\n\nJulia\n\nfunction fib(n)\n    if n &lt;= 1\n        return n\n    else\n        return fib(n-1) + fib(n-2)\n    end\nend\n\nfib (generic function with 1 method)\n\n\n\n\n\nstart_time = time();\nresult = fib(30);\nend_time = time();\n\nprintln(\"Resultado: $result\")\n\nResultado: 832040\n\nprintln(\"Tempo Julia: $(end_time - start_time) segundos\")\n\nTempo Julia: 0.0446321964263916 segundos\n\n\n\n\nstart_time = time();\nresult = fib(40);\nend_time = time();\n\nprintln(\"Resultado: $result\")\n\nResultado: 102334155\n\nprintln(\"Tempo Julia: $(end_time - start_time) segundos\")\n\nTempo Julia: 0.3828909397125244 segundos\n\n\n\n\nPython\n\nimport time\n\ndef fib(n):\n    if n &lt;= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)\n\n\n\n\nstart = time.time()\nresult = fib(30)\nend = time.time()\n\nprint(f\"Resultado: {result}\")\n\nResultado: 832040\n\nprint(f\"Tempo Python: {end - start:.4f} segundos\")\n\nTempo Python: 0.0568 segundos\n\n\n\n\nstart = time.time()\nresult = fib(40)\nend = time.time()\n\nprint(f\"Resultado: {result}\")\n\nResultado: 102334155\n\nprint(f\"Tempo Python: {end - start:.4f} segundos\")\n\nTempo Python: 6.8838 segundos"
  },
  {
    "objectID": "Blog/Velocidade de Processamento.html#resultados-esperados",
    "href": "Blog/Velocidade de Processamento.html#resultados-esperados",
    "title": "Velocidade de Processamento: R vs Julia vs Python",
    "section": "Resultados Esperados",
    "text": "Resultados Esperados\n\nOs tempos de execução podem variar de execução para execução e dependendo do computador sendo utilizado. Para padronizar um pouco os resultados, utilizando a consiguração padrão do Colab e realizamos os testes para fib(40) os valores encontrados foram:\n\nJulia: 1,45 segundos.\nPython: 23,13 segundos.\nR: 159,51 segundos."
  },
  {
    "objectID": "Blog/Velocidade de Processamento.html#conclusão",
    "href": "Blog/Velocidade de Processamento.html#conclusão",
    "title": "Velocidade de Processamento: R vs Julia vs Python",
    "section": "Conclusão",
    "text": "Conclusão\n\nOs testes com a função recursiva de Fibonacci ilustram claramente as diferenças de desempenho entre as linguagens. Embora Julia se destaque em cálculos computacionalmente intensivos devido à sua compilação JIT, a escolha da linguagem deve levar em conta também o ecossistema, a familiaridade do usuário e o tipo de análise a ser realizada.\nPython oferece equilíbrio entre desempenho e facilidade de uso, enquanto R continua sendo a opção ideal para análises estatísticas específicas, com sintaxe concisa e pacotes robustos, apesar de mais lento em cálculos brutos.\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/jupytercolab.html",
    "href": "Blog/jupytercolab.html",
    "title": "Notebooks em Julia: Jupyter e Colab",
    "section": "",
    "text": "A linguagem Julia foi projetada para ser ao mesmo tempo rápida e dinâmica. Quando integrada ao ambiente Jupyter, ela se transforma em uma poderosa ferramenta interativa, que permite combinar código, visualizações gráficas e textos em um único documento, criando um ambiente ideal para o ensino e a aprendizagem.\nNeste post, aprenderemos como instalar o Jupyter e adequá-lo ao ambiente da Julia, bem como a utilizar Julia no queridinho Colab"
  },
  {
    "objectID": "Blog/jupytercolab.html#introdução",
    "href": "Blog/jupytercolab.html#introdução",
    "title": "Notebooks em Julia: Jupyter e Colab",
    "section": "",
    "text": "A linguagem Julia foi projetada para ser ao mesmo tempo rápida e dinâmica. Quando integrada ao ambiente Jupyter, ela se transforma em uma poderosa ferramenta interativa, que permite combinar código, visualizações gráficas e textos em um único documento, criando um ambiente ideal para o ensino e a aprendizagem.\nNeste post, aprenderemos como instalar o Jupyter e adequá-lo ao ambiente da Julia, bem como a utilizar Julia no queridinho Colab"
  },
  {
    "objectID": "Blog/jupytercolab.html#instalação-do-jupyter",
    "href": "Blog/jupytercolab.html#instalação-do-jupyter",
    "title": "Notebooks em Julia: Jupyter e Colab",
    "section": "Instalação do Jupyter",
    "text": "Instalação do Jupyter\n\nPara a baixarmos o Jupyter, temos duas alternativas. A primeira é usando o Python em conjunto com o Julia e a segunda é usando somente o Julia (neste caso pule para a seção: Instalação do Jupyter pelo IJulia).\nUsando as duas linguagens em questão, devemos primeiro instalar o Python. Na página direcionada, você poderá instalar a versão mais nova do Python para o seu sistema operacional (no momento da criação deste post é a versão 3.13).\nCom o arquivo instalado, deveremos deixar habilitado “Add python.exe to PATH” (para permitir usar o comando pip no prompt de comando).\n\n\n\n\nInstalação Python\n\n\n\nEm seguida, abrindo o prompt de comando (coloque “cmd” na barra de procura do Windows), digite pip install jupyter.\n\n\n\n\nInstalando Jupyter\n\n\n\nTendo o Julia e o Jupyter instalados, agora nós instalamos o IJulia. Abrindo o prompt do Julia seguimos com using Pkg e depois Pkg.add(“IJulia”).\n\n\n\n\nTerminal Julia\n\n\n\nFinalmente, abrindo o cmd e digitamos: jupyter notebook. Com o Jupyter aberto, para abrir um notebook, vamos para a barra New e selecionamos o Julia (o número da versão que você instalou). E voilá."
  },
  {
    "objectID": "Blog/jupytercolab.html#instalação-do-jupyter-pelo-ijulia",
    "href": "Blog/jupytercolab.html#instalação-do-jupyter-pelo-ijulia",
    "title": "Notebooks em Julia: Jupyter e Colab",
    "section": "Instalação do Jupyter pelo IJulia",
    "text": "Instalação do Jupyter pelo IJulia\n\nCaso você não queira instalar o Python podemos fazer tudo pelo Julia! Terminando de instalar o IJulia, no terminal, digite using IJulia e em seguida notebook(). Será perguntado se você deseja instalar o Jupyter via Conda, digite y.\n\n\n\n\nInstalando Jupyter (Julia)\n\n\n\nApós esperar o tempo de instalação, temos o Jupyter em mãos!"
  },
  {
    "objectID": "Blog/jupytercolab.html#julia-no-colab",
    "href": "Blog/jupytercolab.html#julia-no-colab",
    "title": "Notebooks em Julia: Jupyter e Colab",
    "section": "Julia no Colab",
    "text": "Julia no Colab\n\nEm 5 de março de 2025, o Google Colab, o Jupyter hospedado na nuvem da Google, adicionou outro tipo de ambiente de execução, a linguagem de programação Julia. Divulgado por Eric Johnson em seu GitHub, o mesmo fala em seu post que além de facilitar o acesso à programação na linguagem Julia, sua introdução ao Google Colab é quase uma homenagem ao Jupyter. Isso porque “Jupyter” é nomeado a partir das três linguagens originalmente suportadas: Julia (“Ju”), Python (“Pyt”) e R (“R”). E agora com Julia sendo adicionado, a tríade das linguagens originais do Jupyter está completa.\nComo colocar Julia no Colab? Muito simples!\nApós criar um novo notebook no Colab. Na aba “Ambiente de execução”, selecione “Alterar o tipo de ambiente de execução”. Depois mude o tipo de ambiente para Julia.\n\n\n\n\nPasso a passo no Colab\n\n\nO ambiente no Colab está pronto para ser usado.\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/positron.html",
    "href": "Blog/positron.html",
    "title": "Programando em Julia com o Positron",
    "section": "",
    "text": "Ao trabalhar com estatística e ciência de dados, duas linguagens costumam se destacar: R e Python. Entre as IDEs mais utilizadas, estão o RStudio e o VSCode — inclusive, já mostramos aqui como configurar ambos para programar em Julia.\nRecentemente, uma nova IDE chamada Positron foi lançada com a proposta de reunir o melhor desses dois ambientes. Desenvolvido pela Posit (antiga RStudio), o Positron pretende se consolidar como a IDE de referência para cientistas e analistas de dados, econometristas e estatísticos, oferecendo recursos avançados em uma interface já familiar.\nEmbora o Positron ofereça apenas suporte nativo apenas para R e Python, é possível configurá-lo para trabalhar também com Julia. Neste post, apresentamos o passo a passo para instalar e preparar a IDE de modo a escrever código em Julia."
  },
  {
    "objectID": "Blog/positron.html#introdução",
    "href": "Blog/positron.html#introdução",
    "title": "Programando em Julia com o Positron",
    "section": "",
    "text": "Ao trabalhar com estatística e ciência de dados, duas linguagens costumam se destacar: R e Python. Entre as IDEs mais utilizadas, estão o RStudio e o VSCode — inclusive, já mostramos aqui como configurar ambos para programar em Julia.\nRecentemente, uma nova IDE chamada Positron foi lançada com a proposta de reunir o melhor desses dois ambientes. Desenvolvido pela Posit (antiga RStudio), o Positron pretende se consolidar como a IDE de referência para cientistas e analistas de dados, econometristas e estatísticos, oferecendo recursos avançados em uma interface já familiar.\nEmbora o Positron ofereça apenas suporte nativo apenas para R e Python, é possível configurá-lo para trabalhar também com Julia. Neste post, apresentamos o passo a passo para instalar e preparar a IDE de modo a escrever código em Julia."
  },
  {
    "objectID": "Blog/positron.html#pré-requisitos",
    "href": "Blog/positron.html#pré-requisitos",
    "title": "Programando em Julia com o Positron",
    "section": "Pré-requisitos",
    "text": "Pré-requisitos\n\nTer o Julia instalado no seu computador."
  },
  {
    "objectID": "Blog/positron.html#instalando-o-positron",
    "href": "Blog/positron.html#instalando-o-positron",
    "title": "Programando em Julia com o Positron",
    "section": "Instalando o Positron",
    "text": "Instalando o Positron\n\nA instalação do Positron pode ser feita diretamente pelo site oficial. Basta acessar o link e escolher a versão compatível com o seu sistema operacional.\n\n\n\n\n\n\n\nAtenção!\n\n\n\nNo Windows, a versão System level instala o Positron para todos os usuários do computador (requer permissões de administrador), enquanto a User level instala apenas para o usuário atual.\n\n\n\n\n\nSite de instalação do Positron\n\n\n\nApós o download, basta seguir os passos tradicionais de instalação. Ao inicializar o Positron pela primeira vez, se você tiver o VSCode instalado, uma mensagem aparecerá perguntando se deseja importar automaticamente todas as suas configurações do VSCode para o Positron. Assim, seu novo ambiente já ficará configurado do jeito que você estava acostumado.\n\n\n\n\nOpção de configuração do Positron\n\n\n\nEsta é a tela inicial que você verá ao abrir o Positron.\n\n\n\n\nTela inicial do Positron"
  },
  {
    "objectID": "Blog/positron.html#instalando-a-extensão-de-julia-no-positron",
    "href": "Blog/positron.html#instalando-a-extensão-de-julia-no-positron",
    "title": "Programando em Julia com o Positron",
    "section": "Instalando a extensão de Julia no Positron",
    "text": "Instalando a extensão de Julia no Positron\n\nCom o Positron devidamente instalado, o próximo passo é instalar a extensão oficial de Julia. Para isso, siga as etapas abaixo:\n\nAbra a aba de extensões usando o atalho Ctrl + shift + X;\nNa barra de busca, digite “Julia”;\nSelecione a extensão oficial e clique em “Install”.\n\n\n\n\n\nInstalando a extensão de Julia"
  },
  {
    "objectID": "Blog/positron.html#programando-em-julia",
    "href": "Blog/positron.html#programando-em-julia",
    "title": "Programando em Julia com o Positron",
    "section": "Programando em Julia",
    "text": "Programando em Julia\n\nCom a extensão instalada, já podemos utilizar Julia no Positron. Agora, vamos criar um novo arquivo clicando no botão New File, localizado no canto superior esquerdo da tela, e selecionando a opção Julia File.\n\n\n\n\nCriando um novo arquivo\n\n\n\nCom o arquivo aberto, vamos criar nosso primeiro código — o clássico “Hello World!”. Para executá-lo, use o atalho Ctrl+Enter ou então clique no botão Run, localizado no canto superior esquerdo.\n\n\n\n\nRodando Julia no Positron\n\n\n\nPronto! Agora você já pode começar a programar e desenvolver seus projetos em Julia com o Positron. Sinta-se livre para explorar todas as funcionalidades disponíveis e aprimorar suas análises!\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/juliahub.html",
    "href": "Blog/juliahub.html",
    "title": "Para que serve o JuliaHub?",
    "section": "",
    "text": "A denominação “Hub”, tanto em JuliaHub quanto em GitHub, refere-se ao termo em inglês que significa “o centro efetivo de uma atividade, região ou rede (de contatos, trabalhos)”. Assim, fica claro que essas redes funcionam como centros de compartilhamento de código em Julia — no caso do JuliaHub, voltado à linguagem Julia; e no caso do GitHub, com foco no controle de versões e ramificações de projetos por meio do Git.\nPlataformas colaborativas de programação são fundamentais para o progresso dos projetos de ciência de dados, computação científica, estatística, etc. Isto, pois facilitam a globalização da informação entre desenvolvedores. Diferentemente de aplicações que hospedam arquivos colaborativos, como o Google Colab ou o Posit Cloud, o JuliaHub permite a criação simultânea de conteúdo pelos participantes do projeto, além de oferecer outras funcionalidades extremamente úteis.\nEntretanto, parte dos recursos da plataforma requer liberação mediante pagamento, que é uma escolha dos desenvolvedores para manter a aplicação ativa e sustentável. Neste tutorial, você aprenderá a utilizar as funções gratuitas do JuliaHub e acessar os recursos pagos, compreendendo suas finalidades."
  },
  {
    "objectID": "Blog/juliahub.html#introdução",
    "href": "Blog/juliahub.html#introdução",
    "title": "Para que serve o JuliaHub?",
    "section": "",
    "text": "A denominação “Hub”, tanto em JuliaHub quanto em GitHub, refere-se ao termo em inglês que significa “o centro efetivo de uma atividade, região ou rede (de contatos, trabalhos)”. Assim, fica claro que essas redes funcionam como centros de compartilhamento de código em Julia — no caso do JuliaHub, voltado à linguagem Julia; e no caso do GitHub, com foco no controle de versões e ramificações de projetos por meio do Git.\nPlataformas colaborativas de programação são fundamentais para o progresso dos projetos de ciência de dados, computação científica, estatística, etc. Isto, pois facilitam a globalização da informação entre desenvolvedores. Diferentemente de aplicações que hospedam arquivos colaborativos, como o Google Colab ou o Posit Cloud, o JuliaHub permite a criação simultânea de conteúdo pelos participantes do projeto, além de oferecer outras funcionalidades extremamente úteis.\nEntretanto, parte dos recursos da plataforma requer liberação mediante pagamento, que é uma escolha dos desenvolvedores para manter a aplicação ativa e sustentável. Neste tutorial, você aprenderá a utilizar as funções gratuitas do JuliaHub e acessar os recursos pagos, compreendendo suas finalidades."
  },
  {
    "objectID": "Blog/juliahub.html#criando-uma-conta",
    "href": "Blog/juliahub.html#criando-uma-conta",
    "title": "Para que serve o JuliaHub?",
    "section": "Criando uma conta",
    "text": "Criando uma conta\n\nAo acessar o site oficial do JuliaHub, a seleção do ícone de usuário o redirecionará para uma página com seis opções de login: por e-mail, GitHub, GitLab, Google e Linkedin. Após escolher uma das alternativas e acessar com sua conta, será necessário preencher os seguintes dados:\n\n\n\n\n\n\n\nO título a ser preenchido corresponde ao seu cargo ou função dentro da organização mencionada.\n\n\n\n\n\n\n\nApós completar as informações e selecionar “enviar”, você será direcionado para a página inicial da plataforma, onde encontrará seis funções principais disponíveis para acesso:\n\nAplicações\nNotebooks\nProjetos\nPergunte à IA\nPacotes\nRecursos"
  },
  {
    "objectID": "Blog/juliahub.html#aplicações-notebook-e-projetos",
    "href": "Blog/juliahub.html#aplicações-notebook-e-projetos",
    "title": "Para que serve o JuliaHub?",
    "section": "Aplicações, Notebook e Projetos",
    "text": "Aplicações, Notebook e Projetos\n\nNa aba Aplicações, é possível carregar Pluto Notebooks na nuvem, que são os alternativas em Julia aos Jupyter Notebooks (comoo os criados no Google Colab, por exemplo). Além disso, há a opção de carregar um ambiente de desenvolvimento completo com o Julia IDE, também em nuvem. Por fim, o Dyad Studio (antigo JuliaSim) consiste em uma plataforma avançada para desenvolvimento, refinamento, análise e implantação de modelos, e pode ser utilizado diretamente a partir do JuliaHub.\nApesar da grande utilidade para o público geral, o uso dessas funções exige o pagamento de USD 1,40 por hora de atividade (valores de jul. 2025), o que as torna inacessíveis para uma grande parte dos usuários — especialmente estudantes, que podem emular os códigos em outras plataformas colaborativas, ou que atuam com linguagens de programação já consolidadas no meio acadêmico, mas que ainda não incluem Julia de forma significativa."
  },
  {
    "objectID": "Blog/juliahub.html#julia-e-ia",
    "href": "Blog/juliahub.html#julia-e-ia",
    "title": "Para que serve o JuliaHub?",
    "section": "Julia e IA",
    "text": "Julia e IA\n\nEm parceria com a OpenAI, a plataforma oferece seu próprio acesso à Inteligência Artificial, voltado para perguntas específicas sobre a linguagem Julia. Ainda em versão Beta no momento da redação desta postagem, as respostas são geradas a partir do banco de dados interno do JuliaHub. A seguir, apresenta-se um teste realizado para avaliar a qualidade e a precisão das respostas fornecidas pela IA:\n\n\n\n\n\n\n\n\n\n\n\n\nDe forma rápida e eficiente, a IA retorna instruções claras e exemplificadas sobre o que foi perguntado, além de incluir extensões consideradas relevantes pelo sistema que a opera. No teste apresentado acima, além de responder diretamente à questão sobre a variância clássica, a IA também trouxe informações complementares sobre a variância ponderada, os pacotes necessários para usar as funções mencionadas, como criar o vetor de dados na linguagem Julia e como exibir a saída de forma personalizada."
  },
  {
    "objectID": "Blog/juliahub.html#pacotes",
    "href": "Blog/juliahub.html#pacotes",
    "title": "Para que serve o JuliaHub?",
    "section": "Pacotes",
    "text": "Pacotes\n\nNa sessão Pacotes, o usuário tem acesso a 1248 páginas de pacotes em Julia criados por colaboradores da plataforma. É possível buscar pacotes por categoria, utilizando o filtro em “Tópicos”, ou procurar por pacotes específicos digitando o nome (ou parte dele) na lupa no canto superior direito.\nOutro filtro disponível é o de “Licenças”, que são os documentos que definem como um pacote pode ser usado, modificado e distribuído. Dependendo da licença, o pacote pode ser limitado, por exemplo, apenas para fins pessoais, não permitindo o uso comercial. A licença também pode permitir ou proibir modificações no código-fonte, a redistribuição do pacote (ou de versões modificadas), além de estabelecer condições específicas de uso — como a obrigatoriedade de creditar o autor original.\nAo selecionar a pasta da “Fonte” do pacote desejado, a plataforma redireciona o usuário para a página correspondente no GitHub, onde é possível fazer o download do pacote compilado ou copiar o link para instalá-lo em seu ambiente de desenvolvimento.\n\n\n\n\n\n\n\nAtualmente, a plataforma conta com 12.399 pacotes ativos, e você também pode colaborar com a comunidade de Julia registrando suas criações! A opção de registrar um novo pacote é gratuita e está disponível para todos os usuários. Para isso, é necessário fornecer as seguintes informações sobre o pacote que será compartilhado:"
  },
  {
    "objectID": "Blog/juliahub.html#recursos",
    "href": "Blog/juliahub.html#recursos",
    "title": "Para que serve o JuliaHub?",
    "section": "Recursos",
    "text": "Recursos\n\nAo selecionar a opção Recursos, você terá acesso à documentação oficial do JuliaHub, ao contato do suporte e à seção de feedback, onde é possível avaliar sua experiência na plataforma e sugerir melhorias aos desenvolvedores.\nAlém disso, em Julia Binaries, é possível baixar os arquivos executáveis de Julia prontos para instalação — ou seja, pacotes compilados para diferentes sistemas operacionais e em diversas versões. Para aprender como baixar e configurar Julia direto na sua máquina, basta acessar os tutoriais já publicados no Blog!\nPor último, a ferramenta “Explorar Webinars” redireciona o usuário para uma página com todos os Seminários Online, tanto os já realizados quanto os que ainda vão acontecer, organizados pela plataforma e seus parceiros. Para se inscrever para o próximo evento ou acessar um já ocorrido, selecione o seminário desejado e os dados da sua conta no JuliaHub serão automaticamente preenchidos no formulário. Caso o evento já tiver ocorrido, ao clicar em “Registre-se” (ou “Enviar”, no caso de seminários mais antigos) a gravação ficará instantaneamente disponível na própria página. Caso o seminário ainda vá acontecer, um convite do Zoom será enviado automaticamente para o e-mail associado à sua conta.\nAs informações exibidas na página principal de cada evento incluem a identificação dos oradores responsáveis pelo seminário, um resumo do tema abordado e sua motivação, além dos principais destaques que serão apresentados ao longo da sessão.\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/strings.html",
    "href": "Blog/strings.html",
    "title": "Manipulação de strings em Julia",
    "section": "",
    "text": "Manipular strings é uma habilidade essencial em análise de dados, seja para organizar nomes de variáveis, corrigir e padronizar informações textuais ou gerar relatórios automatizados ou mesmo para realizar tarefaz de text mining. Em Julia podemos realizar operações básicas até buscas complexas com expressões regulares.\nNeste post, exploraremos como criar, modificar e formatar strings utilizando apenas recursos do Julia base."
  },
  {
    "objectID": "Blog/strings.html#introdução",
    "href": "Blog/strings.html#introdução",
    "title": "Manipulação de strings em Julia",
    "section": "",
    "text": "Manipular strings é uma habilidade essencial em análise de dados, seja para organizar nomes de variáveis, corrigir e padronizar informações textuais ou gerar relatórios automatizados ou mesmo para realizar tarefaz de text mining. Em Julia podemos realizar operações básicas até buscas complexas com expressões regulares.\nNeste post, exploraremos como criar, modificar e formatar strings utilizando apenas recursos do Julia base."
  },
  {
    "objectID": "Blog/strings.html#criação-de-strings",
    "href": "Blog/strings.html#criação-de-strings",
    "title": "Manipulação de strings em Julia",
    "section": "Criação de strings",
    "text": "Criação de strings\n\nEm Julia, criamos um objeto do tipo String colocando o texto entre aspas duplas (\") ou três aspas duplas (\"\"\"). As duas maneiras de criar o objeto são equivalentes, então sinta-se à vontade para usar a que preferir.\n\n\n\"a\"\n\n\"a\"\n\n\"\"\"a\"\"\"\n\n\"a\"\n\n\"a\" == \"\"\"a\"\"\"\n\ntrue\n\n\n\nAlém disso, é importante estar atento a comandos especiais, como o \\n, que representa uma quebra de linha. Para criar um objeto que ignore qualquer caractere especial, ou seja, que contenha apenas o texto literal, basta prefixar a string com raw antes das aspas.\n\n\n\"a\nb\"\n\n\"a\\nb\"\n\nprint(\"a\\nb\")\n\na\nb\n\nprint(raw\"a\\nb\")\n\na\\nb"
  },
  {
    "objectID": "Blog/strings.html#caracteres",
    "href": "Blog/strings.html#caracteres",
    "title": "Manipulação de strings em Julia",
    "section": "Caracteres",
    "text": "Caracteres\n\nUm detalhe importante em Julia é a distinção entre dois tipos de objetos: String e Char. Ambos representam textos, mas Char contém apenas um caractere e é criado com aspas simples (') em vez de aspas duplas.\n\n\ntypeof(\"a\")\n\nString\n\ntypeof('a')\n\nChar\n\n\n\nObjetos do tipo Char possuem algumas particularidades interessantes. Por exemplo, eles são compatíveis com operações de soma e subtração, nas quais a diferença entre os códigos Unicode dos caracteres é calculada.\n\n\n'A' + 1\n\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n\n'E' - 'C'\n\n2\n\n\n\nO funcionamento dos caracteres está relacionado ao Unicode/UTF-8, uma codificação de caracteres que inclui letras tradicionais e caracteres especiais. Para conferir todos os códigos disponíveis, basta acessar este link. Para utilizar um caractere por meio do código UTF-8, basta utilizar \\u seguido do respectivo código.\n\n\n'\\u2200'\n\n'∀': Unicode U+2200 (category Sm: Symbol, math)"
  },
  {
    "objectID": "Blog/strings.html#junção-e-separação",
    "href": "Blog/strings.html#junção-e-separação",
    "title": "Manipulação de strings em Julia",
    "section": "Junção e separação",
    "text": "Junção e separação\n\nA maneira mais básica de unir strings é por meio do operador *, que combina os textos em uma única string.\n\n\n\"banana\" * \" \" * \"pera\"\n\n\"banana pera\"\n\n\n\nPara unificar todas as strings contidas em um vetor, basta utilizar a função join() e especificar qual será o separador entre os elementos. E para realizar o processo inverso, ou seja, separar uma string em um vetor, utiliza-se a função split(), especificando o ponto em que os cortes devem ser feitos.\n\n\nfrutas = [\"banana\", \"pera\", \"morango\"];\njoin(frutas, \", \")\n\n\"banana, pera, morango\"\n\njoin(frutas, \"-\")\n\n\"banana-pera-morango\"\n\nsplit(\"banana-pera-morango\", \"-\")\n\n3-element Vector{SubString{String}}:\n \"banana\"\n \"pera\"\n \"morango\"\n\n\n\nTambém é possível copiar uma string várias vezes por meio da função repeat, que retorna uma nova string com o texto replicado pelo número de vezes especificado.\n\n\nrepeat(\"ba\", 5)\n\n\"bababababa\""
  },
  {
    "objectID": "Blog/strings.html#busca-e-substituição",
    "href": "Blog/strings.html#busca-e-substituição",
    "title": "Manipulação de strings em Julia",
    "section": "Busca e substituição",
    "text": "Busca e substituição\n\nPara acessar partes de uma string, o processo é semelhante ao acesso a um vetor, em que cada caractere é tratado como um elemento. Podemos tanto selecionar uma única posição, obtendo um Char, ou uma sequência de caracteres, resultando em uma nova string.\n\n\n\"abcd\"[1]     # Primeiro elemento\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\"abcd\"[end]   # Último elemento\n\n'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n\n\"abcd\"[2:end] # Do segundo ao último elemento\n\n\"bcd\"\n\n\n\n\n\n\n\n\nObservação\n\n\n\nAo extrair apenas um caractere de uma string, o tipo de objeto retornado pode variar a depender da forma como a extração é realizada.\n\n\"abcd\"[1]   # Char\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\"abcd\"[1:1] # String\n\n\"a\"\n\n\n\n\n\nEm Julia, é possível realizar buscas dentro de strings de diferentes maneiras. Uma abordagem mais avançada é o uso de expressões regulares, que permitem buscar padrões complexos de texto. Podemos criar uma expressão regular prefixando a string com a letra r.\n\n\nr\".\" # Metacaractere que corresponde a qualquer caractere\n\nr\".\"\n\n\n\nPara aprender mais sobre a sintaxe completa de expressões regulares, você pode acessar este link. No entanto, Julia também oferece funções simples para buscar texto diretamente, sem precisar de regex:\n\noccursin(): verifica se determinado texto está presente na string.\nfindfirst(): retorna a posição da primeira ocorrência do texto na string.\nfindlast(): retorna a posição da última ocorrência do texto na string.\n\n\n\ntexto = \"Zero ao Julia\"\n\n\"Zero ao Julia\"\n\noccursin(\"Julia\", texto)   \n\ntrue\n\nfindfirst(\"a\", texto)  \n\n6:6\n\nfindlast(\"a\", texto)       \n\n13:13\n\n\n\nAs funções startswith() e endswith() verificam, respectivamente, se uma string começa ou termina com um determinado texto.\n\n\ntexto = \"Julia\"\n\n\"Julia\"\n\nstartswith(texto, \"j\")\n\nfalse\n\nendswith(texto, \"ia\")\n\ntrue\n\nstartswith(texto, \"J\")\n\ntrue\n\n\n\nTambém é possível substituir trechos de texto em uma string utilizando a função replace.\n\n\nreplace(\"banana\", \"a\" =&gt; \"o\")\n\n\"bonono\""
  },
  {
    "objectID": "Blog/strings.html#formatações",
    "href": "Blog/strings.html#formatações",
    "title": "Manipulação de strings em Julia",
    "section": "Formatações",
    "text": "Formatações\n\nPara alternar as letras de uma string entre maiúsculas e minúsculas, existem três funções principais:\n\nuppercase: converte todas as letras para maiúsculas.\nlowercase: converte todas as letras para minúsculas.\ntitlecase: converte a primeira letra de cada palavra para maiúscula e as demais para minúscula.\n\n\n\ntexto = \"ZERO ao julia\"\n\n\"ZERO ao julia\"\n\nuppercase(texto)\n\n\"ZERO AO JULIA\"\n\nlowercase(texto)\n\n\"zero ao julia\"\n\ntitlecase(texto)\n\n\"Zero Ao Julia\"\n\n\n\nComo não existe uma função específica para capitalizar apenas a primeira letra da string (deixando as demais minúsculas), é necessário combinar uppercase com lowercase para realizar esse processo.\n\n\nuppercase(texto[1]) * lowercase(texto[2:end])\n\n\"Zero ao julia\"\n\n\n\nAlém disso, com a função reverse, é possível obter os caracteres de uma string em ordem inversa.\n\n\nreverse(\"abcde\")\n\n\"edcba\"\n\n\n\nTambém é possível remover espaços em branco de uma string de maneira simples. Para eliminar espaços apenas no início, utiliza-se lstrip(); apenas no final, rstrip(); e em ambas as extremidades, strip().\n\n\nlstrip(\"  julia  \")\n\n\"julia  \"\n\nrstrip(\"  julia  \")\n\n\"  julia\"\n\nstrip(\"  julia  \")\n\n\"julia\""
  },
  {
    "objectID": "Blog/strings.html#interpolação-com-variáveis-e-números",
    "href": "Blog/strings.html#interpolação-com-variáveis-e-números",
    "title": "Manipulação de strings em Julia",
    "section": "Interpolação com variáveis e números",
    "text": "Interpolação com variáveis e números\n\nPor fim, é possível inserir expressões e valores de variáveis diretamente dentro de strings usando a sintaxe $().\n\n\na = 2\n\n2\n\nb = 5\n\n5\n\n\"Soma: $(a+b)\"\n\n\"Soma: 7\""
  },
  {
    "objectID": "Blog/strings.html#conclusão",
    "href": "Blog/strings.html#conclusão",
    "title": "Manipulação de strings em Julia",
    "section": "Conclusão",
    "text": "Conclusão\n\nPortanto, manipular strings com eficiência em Julia é essencial, já que dados raramente chegam prontos para análise. Ao dominar essas técnicas, você poderá limpar, formatar e organizar informações textuais com facilidade, utilizando-as de forma natural em seus projetos.\n\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "Blog/julia_rstudio.html",
    "href": "Blog/julia_rstudio.html",
    "title": "Como utilizar Julia no RStudio no Windows",
    "section": "",
    "text": "Ao trabalhar com Estatística, uma das linguagens de programação mais utilizadas é o R, criado especificamente para esse propósito. Para facilitar seu uso, o RStudio se destaca como a principal interface, oferecendo um ambiente amigável e com recursos que otimizam a programação. Além disso, o RStudio permite integração com outras linguagens, como Python e Julia.\nNeste post, vamos aprender como utilizar Julia no RStudio, aproveitando os recursos de uma linguagem poderosa dentro de um ambiente já conhecido por muitos usuários de R."
  },
  {
    "objectID": "Blog/julia_rstudio.html#introdução",
    "href": "Blog/julia_rstudio.html#introdução",
    "title": "Como utilizar Julia no RStudio no Windows",
    "section": "",
    "text": "Ao trabalhar com Estatística, uma das linguagens de programação mais utilizadas é o R, criado especificamente para esse propósito. Para facilitar seu uso, o RStudio se destaca como a principal interface, oferecendo um ambiente amigável e com recursos que otimizam a programação. Além disso, o RStudio permite integração com outras linguagens, como Python e Julia.\nNeste post, vamos aprender como utilizar Julia no RStudio, aproveitando os recursos de uma linguagem poderosa dentro de um ambiente já conhecido por muitos usuários de R."
  },
  {
    "objectID": "Blog/julia_rstudio.html#pré-requisitos",
    "href": "Blog/julia_rstudio.html#pré-requisitos",
    "title": "Como utilizar Julia no RStudio no Windows",
    "section": "Pré Requisitos",
    "text": "Pré Requisitos\n\nTer Julia instalado;\nTer R e Rstudio instalados."
  },
  {
    "objectID": "Blog/julia_rstudio.html#configurações-do-rstudio",
    "href": "Blog/julia_rstudio.html#configurações-do-rstudio",
    "title": "Como utilizar Julia no RStudio no Windows",
    "section": "Configurações do RStudio",
    "text": "Configurações do RStudio\nPara integrar o Julia ao RStudio, vamos utilizar o pacote JuliaCall. Para isso, precisamos instalá-lo e carregá-lo:\n\ninstall.packages(\"JuliaCall\")\nlibrary(JuliaCall)\n\nCom o pacote devidamente carregado, é necessário informar ao RStudio onde está instalado o Julia no seu computador. Para isso, buscamos pelo arquivo julia.exe no gerenciador de arquivos, como mostrado na imagem abaixo:\n\n\n\nPesquisando o caminho do Julia no computador\n\n\nNo caso, estamos interessados no segundo julia.exe, aquele que foi criado no processo de instalação do Julia. Voltando ao R, utilizamos as funções Sys.setenv() e julia_setup() para configurar o caminho do arquivo. No meu caso, ficou assim:\n\nSys.setenv(JULIA_HOME = \"C:/Users/vitor/AppData/Local/Programs/Julia-1.10.2/bin\"\njulia_setup()\n\nPronto, agora já é possível utilizar o Julia no Rstudio!\n\n\n\n\n\n\nObservação\n\n\n\nUma forma alternativa é escrever no terminal\n\nwhich julia\n\nou\n\nwhere julia\n\ndependendo se é usuário de Linux/Unix ou de Windows."
  },
  {
    "objectID": "Blog/julia_rstudio.html#como-utilizar",
    "href": "Blog/julia_rstudio.html#como-utilizar",
    "title": "Como utilizar Julia no RStudio no Windows",
    "section": "Como utilizar",
    "text": "Como utilizar\nCom tudo configurado, podemos começar a usar o Julia no RStudio. Para isso, criamos um arquivo R Markdown e escrevemos o código em Julia dentro do chunck Julia:\n\n\n\nChunk Julia\n\n\nAgora é só colocar a mão na massa e começar a programar em Julia diretamente no RStudio, uma interface que você já conhece bem!\n\n\n\n\n\n\nNota\n\n\n\nFerramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Equipe/Atual/caio_frare.html",
    "href": "Equipe/Atual/caio_frare.html",
    "title": "Caio Frare",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n\n      \n\n    \n    \n  \n\n\nGraduando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/heitor_bgs.html",
    "href": "Equipe/Atual/heitor_bgs.html",
    "title": "Heitor Brotto Gomes e Silva",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n  \n    \n     Site\n  \n\n\n\nGraduando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/thiago_paulichen.html",
    "href": "Equipe/Atual/thiago_paulichen.html",
    "title": "Thiago Paulichen",
    "section": "",
    "text": "Lattes\n  \n  \n    \n     Github\n  \n  \n    \n     Linkedin\n  \n\n      \n\n    \n    \n  \n\n\nEstudante de Doutorado em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/sarah_silva.html",
    "href": "Equipe/Atual/sarah_silva.html",
    "title": "Sarah Silva",
    "section": "",
    "text": "Graduanda em Matemática Aplicada e Computacional. Pesquisadora Colaboradora em Iniciação Científica em Centro Nacional de Pesquisa em Energia e Materiais (CNPEM).\n \n  \n   \n  \n    \n     Github\n  \n  \n    \n     Linkedin"
  },
  {
    "objectID": "Equipe/Atual/henrique_velloso.html",
    "href": "Equipe/Atual/henrique_velloso.html",
    "title": "Henrique Velloso",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n\n      \nGraduando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/Leonardo_dos_Santos.html",
    "href": "Equipe/Atual/Leonardo_dos_Santos.html",
    "title": "Leonardo dos Santos",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n\n      \nGraduando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Atual/arthur_dionizio.html",
    "href": "Equipe/Atual/arthur_dionizio.html",
    "title": "Arthur Dionizio",
    "section": "",
    "text": "Github\n  \n  \n    \n     Linkedin\n  \n\n      \nGraduando em Matemática Aplicada e Computacional pela UNICAMP."
  },
  {
    "objectID": "Equipe/Antigos/thiago.html",
    "href": "Equipe/Antigos/thiago.html",
    "title": "Thiago Paulichen",
    "section": "",
    "text": "Lattes\n  \n\n\n\nDoutorando em Estatística pela UNICAMP."
  },
  {
    "objectID": "Equipe/Antigos/carlos_trucios.html",
    "href": "Equipe/Antigos/carlos_trucios.html",
    "title": "Carlos Trucíos",
    "section": "",
    "text": "Website\n  \n  \n    \n     Lattes\n  \n  \n    \n     Scholar\n  \n  \n    \n     Github\n  \n  \n    \n     Linkedin\n  \n\n      \n\n    \n    \n  \n\n\nCoordenador do projeto e Professor do Departamento de Estatística do IMECC desde 2022.\n\nSala: 206 - IMECC\nE-mail: ctrucios at unicamp dot br"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Entrevistas - Abel Soares Siqueira e Paulo José da Silva e Silva\n\n\n\n\n\n\nJulia\n\n\nEntrevistas\n\n\nMercado de Trabalho\n\n\nMeio Acadêmico\n\n\n\nNeste post, conversamos com dois profissionais de destaque que utilizam Julia no dia a dia. Descubra suas experiências, insights e dicas sobre como a linguagem impacta seu trabalho! \n\n\n\n\n\n19 de set. de 2025\n\n\nLeonardo dos Santos, Ana Luisa Pereira da Silva Rodrigues\n\n\n\n\n\n\n\n\n\n\n\n\nVelocidade de Processamento: R vs Julia vs Python\n\n\n\n\n\n\nBenchmark\n\n\n\nPara quem lida com grandes volumes de dados ou cálculos complexos, conhecer a velocidade de execução das linguagens é fundamental. Neste post, comparamos R, Julia e Python por meio de uma função de Fibonacci, mostrando como a escolha da linguagem pode fazer diferença no tempo de processamento e na produtividade. \n\n\n\n\n\n19 de set. de 2025\n\n\nGabriel Campovilla da Silva, Nicole Fredericci\n\n\n\n\n\n\n\n\n\n\n\n\nManipulação de strings em Julia\n\n\n\n\n\n\nPrimeiros Passos\n\n\nFerramentas\n\n\n\nAprender a manipular strings em Julia é essencial para transformar dados brutos em informações úteis. Neste post, você vai conhecer desde os conceitos básicos até operações e formatações mais avançadas, aprendendo a organizar, padronizar e preparar seus dados de forma eficiente para qualquer análise. \n\n\n\n\n\n14 de set. de 2025\n\n\nVitor Ribas Perrone, Nicole Fredericci\n\n\n\n\n\n\n\n\n\n\n\n\nManipulação de datas em Julia\n\n\n\n\n\n\nPrimeiros Passos\n\n\nFerramentas\n\n\n\nAprenda a criar, acessar e manipular datas em Julia, incluindo operações aritméticas e comparações entre períodos de tempo. \n\n\n\n\n\n14 de set. de 2025\n\n\nVitor Ribas Perrone, Nicole Fredericci\n\n\n\n\n\n\n\n\n\n\n\n\nPacotes com Bancos de Dados para trabalhar em Julia\n\n\n\n\n\n\nPacotes\n\n\nPrimeiros Passos\n\n\n\nOs dados são a matéria-prima do nosso trabalho. Pensando nisso, hoje vamos apresentar alguns pacotes em Julia que permitem acessar conjuntos de dados prontos para uso. Eles são ótimos para colocar em prática o que você vem aprendendo ao longo da jornada, testar novas ideias de análise ou até mesmo enriquecer o seu portfólio com projetos reais. \n\n\n\n\n\n5 de set. de 2025\n\n\nVitor Ribas Perrone, Nicole Fredericci\n\n\n\n\n\n\n\n\n\n\n\n\nProgramando em Julia com o Positron\n\n\n\n\n\n\nInstalação\n\n\nIDE\n\n\n\nGuia prático para instalar e começar a usar Julia na IDE Positron \n\n\n\n\n\n28 de ago. de 2025\n\n\nVitor Ribas Perrone, Nicole Fredericci\n\n\n\n\n\n\n\n\n\n\n\n\nMatrizes em Julia\n\n\n\n\n\n\nMatriz\n\n\n\nMatrizes são estruturas centrais em diversas aplicações científicas e computacionais, e Julia oferece ferramentas poderosas e eficientes para manipulá-las de forma intuitiva. Neste post, você aprenderá a criar matrizes, acessar elementos, realizar operações e explorar suas principais propriedades. \n\n\n\n\n\n26 de ago. de 2025\n\n\nCaio Frare, Nicole Fredericci\n\n\n\n\n\n\n\n\n\n\n\n\nPerspectivas de Julia para o Futuro\n\n\n\n\n\n\nHistória\n\n\n\nSaiba mais sobre o crescimento da popularidade dessa linguagem de programação, suas principais áreas de aplicação e seu potencial de expansão. \n\n\n\n\n\n21 de ago. de 2025\n\n\nEsther Cleveston, Nicole Fredericci\n\n\n\n\n\n\n\n\n\n\n\n\nÁlgebra linear com LinearAlgebra.jl\n\n\n\n\n\n\nPacotes\n\n\nFerramentas\n\n\nManipulação de Dados\n\n\n\nAprenda e utilize álgebra linear com LinearAlgebra.jl. \n\n\n\n\n\n3 de ago. de 2025\n\n\nSarah Pereira Teixeira Silva\n\n\n\n\n\n\n\n\n\n\n\n\nPara que serve o JuliaHub?\n\n\n\n\n\n\nFerramentas\n\n\nOnline\n\n\n\nPlataformas colaborativas de programação são fundamentais para o avanço dos projetos de ciência de dados, computação científica, estatística, etc. Itso, pois facilitam a globalização da informação entre desenvolvedores. Se você deseja compartilhar projetos em Julia e se manter atualizado sobre as novidades da linguagem, aprenda neste tutorial como utilizar o JuliaHub. \n\n\n\n\n\n3 de ago. de 2025\n\n\nNicole Fredericci\n\n\n\n\n\n\n\n\n\n\n\n\nJulia no Mercado de Trabalho\n\n\n\n\n\n\nJulia\n\n\nMercado de Trabalho\n\n\n\nComo a linguagem Julia, comumente vista no meio acadêmico, é utilizada pelas grandes empresas no mercado de trabalho? \n\n\n\n\n\n2 de ago. de 2025\n\n\nLeonardo dos Santos\n\n\n\n\n\n\n\n\n\n\n\n\nComo programar em Julia no Vscode\n\n\n\n\n\n\nIDE\n\n\n\nAprenda o como utilizar o Julia no Vscode, da configuração aos primeiros passos. \n\n\n\n\n\n5 de jul. de 2025\n\n\nGuilherme Duarte, Pedro H. G. Elias\n\n\n\n\n\n\n\n\n\n\n\n\nComo criar relatórios dinâmicos com Julia e Pluto\n\n\n\n\n\n\nMarkdown\n\n\n\nCriação de relatórios dinâmicos em Julia com Pluto.jl: um ambiente de notebooks reativo e fácil de usar, feito sob medida para a linguagem \n\n\n\n\n\n1 de jul. de 2025\n\n\nVitor Ribas Perrone, Guilherme Duarte Alves Basso\n\n\n\n\n\n\n\n\n\n\n\n\nIntrodução ao pacote TidierData.jl\n\n\n\n\n\n\nManipulação de Dados\n\n\nTidy Data\n\n\nFerramentas\n\n\nPacotes\n\n\n\nUm guia introdutório sobre o pacote TidierData.jl! Entenda como aplicar a gramática tidy para manipulação de dados de forma intuitiva, utilizando funções familiares para quem vem do tidyverse em R. \n\n\n\n\n\n14 de jun. de 2025\n\n\nHenrique Anunciação Velloso Silva, Arthur Dionizio Martins da Silva\n\n\n\n\n\n\n\n\n\n\n\n\nPacotes Essenciais para Trabalhar com Estatística em Julia\n\n\n\n\n\n\nPacotes\n\n\nPrimeiros Passos\n\n\n\nPrincipais pacotes para realizar as mais diversas análises estatísticas em Julia.\n\n\n\n\n\n13 de jun. de 2025\n\n\nVitor Ribas Perrone, Arthur Dionizio Martins da Silva\n\n\n\n\n\n\n\n\n\n\n\n\nEntenda a História da Linguagem que une Simplicidade e Desempenho\n\n\n\n\n\n\nHistória\n\n\n\nConheça a história do Julia, que surgiu com a proposta de unir o desempenho e a simplicidade em uma só linguagem. \n\n\n\n\n\n12 de jun. de 2025\n\n\nEsther Cleveston, Pedro H. G. Elias\n\n\n\n\n\n\n\n\n\n\n\n\nComo utilizar Julia no RStudio no Windows\n\n\n\n\n\n\nInstalação\n\n\nIDE\n\n\n\nPasso a passo para configurar Julia no Rstudio\n\n\n\n\n\n18 de mai. de 2025\n\n\nVitor Ribas Perrone, Carlos Trucíos\n\n\n\n\n\n\n\n\n\n\n\n\nNotebooks em Julia: Jupyter e Colab\n\n\n\n\n\n\nInstalação\n\n\n\nAprenda passo a passo como instalar e utilizar os ambientes Jupyter e Colab integrados à linguagem Julia. \n\n\n\n\n\n13 de mai. de 2025\n\n\nGabriel Cardoso, Carlos Trucíos\n\n\n\n\n\n\n\n\n\n\n\n\nComo instalar Julia?\n\n\n\n\n\n\nInstalação\n\n\n\nPasso a passo para instalar e configurar Julia no seu computador. \n\n\n\n\n\n2 de mai. de 2025\n\n\nNicole Fredericci, Carlos Trucíos\n\n\n\n\n\n\n\n\n\n\n\n\nDo Zero ao Julia: As origens\n\n\n\n\n\n\nHistória\n\n\n\nFicou curioso sobre como tudo começou? Descubra, de forma leve e descontraída, como o projeto foi idealizado, planejado e finalmente lançado ao público. \n\n\n\n\n\n24 de abr. de 2025\n\n\nCarlos Trucíos\n\n\n\n\n\n\n\n\n\n\n\n\nComo fazer um post no Blog com Quarto?\n\n\n\n\n\n\nQuarto\n\n\n\nBreve post explicando o passo a passo para fazer posts utilizando Quarto. \n\n\n\n\n\n10 de abr. de 2025\n\n\nCarlos Trucíos, Maria Silva\n\n\n\n\n\n\nNenhum item correspondente"
  },
  {
    "objectID": "Tutoriais/TSQLite.html",
    "href": "Tutoriais/TSQLite.html",
    "title": "Um pouco mais sobre SQLite em Julia",
    "section": "",
    "text": "O SQLite apresenta-se como uma biblioteca singular no universo dos Sistemas de Gerenciamento de Banco de Dados (SGBDs). Diferentemente das soluções tradicionais, que exigem um servidor dedicado e configurações complexas, o SQLite integra-se diretamente à aplicação, oferecendo um mecanismo de banco de dados SQL autônomo, sem servidor e de configuração nula. Essa característica fundamental o torna uma opção extremamente atraente para uma vasta gama de usos, desde dispositivos móveis e sistemas embarcados até aplicações para desktop.\n\n\nA natureza “sem servidor” do SQLite elimina a necessidade de um processo de servidor separado para gerenciar o banco de dados. Em vez disso, a biblioteca interage diretamente com um único arquivo no disco, no qual reside toda a estrutura do banco de dados, incluindo tabelas, índices, gatilhos e visões. Essa abordagem simplificada não apenas facilita a implantação e o gerenciamento, mas também contribui para um menor consumo de recursos, tornando o SQLite ideal para ambientes com limitações de hardware.\n\n\n\nAdemais, a licença de domínio público do SQLite garante sua utilização gratuita para qualquer propósito, seja ele comercial ou privado. Essa liberdade de uso, aliada à sua portabilidade — que permite ao arquivo de banco de dados funcionar em qualquer plataforma — e ao seu tamanho compacto de aproximadamente 600 KB, reforça sua versatilidade e ampla aplicabilidade. A designação LTS (Long-Term Support) assegura a estabilidade e a continuidade do suporte, conferindo confiança aos desenvolvedores que optam por integrar o SQLite em seus projetos."
  },
  {
    "objectID": "Tutoriais/TSQLite.html#sqlite-uma-solução-de-banco-de-dados-leve-e-versátil",
    "href": "Tutoriais/TSQLite.html#sqlite-uma-solução-de-banco-de-dados-leve-e-versátil",
    "title": "Um pouco mais sobre SQLite em Julia",
    "section": "",
    "text": "O SQLite apresenta-se como uma biblioteca singular no universo dos Sistemas de Gerenciamento de Banco de Dados (SGBDs). Diferentemente das soluções tradicionais, que exigem um servidor dedicado e configurações complexas, o SQLite integra-se diretamente à aplicação, oferecendo um mecanismo de banco de dados SQL autônomo, sem servidor e de configuração nula. Essa característica fundamental o torna uma opção extremamente atraente para uma vasta gama de usos, desde dispositivos móveis e sistemas embarcados até aplicações para desktop.\n\n\nA natureza “sem servidor” do SQLite elimina a necessidade de um processo de servidor separado para gerenciar o banco de dados. Em vez disso, a biblioteca interage diretamente com um único arquivo no disco, no qual reside toda a estrutura do banco de dados, incluindo tabelas, índices, gatilhos e visões. Essa abordagem simplificada não apenas facilita a implantação e o gerenciamento, mas também contribui para um menor consumo de recursos, tornando o SQLite ideal para ambientes com limitações de hardware.\n\n\n\nAdemais, a licença de domínio público do SQLite garante sua utilização gratuita para qualquer propósito, seja ele comercial ou privado. Essa liberdade de uso, aliada à sua portabilidade — que permite ao arquivo de banco de dados funcionar em qualquer plataforma — e ao seu tamanho compacto de aproximadamente 600 KB, reforça sua versatilidade e ampla aplicabilidade. A designação LTS (Long-Term Support) assegura a estabilidade e a continuidade do suporte, conferindo confiança aos desenvolvedores que optam por integrar o SQLite em seus projetos."
  },
  {
    "objectID": "Tutoriais/TSQLite.html#usando-julia-como-interface-para-sqlite",
    "href": "Tutoriais/TSQLite.html#usando-julia-como-interface-para-sqlite",
    "title": "Um pouco mais sobre SQLite em Julia",
    "section": "Usando Julia como Interface para SQLite",
    "text": "Usando Julia como Interface para SQLite\nA linguagem Julia possui o pacote SQLite.jl, que disponibiliza todos os recursos da biblioteca SQLite diretamente em seu ambiente. Embora os comandos sejam executados a partir do Julia, eles são repassados e processados diretamente pelo motor do SQLite. Este motor, por sua vez, é instalado automaticamente quando o pacote SQLite.jl é adicionado.\n\nusing Pkg  # Carrega o pacote Pkg, responsável por gerenciar pacotes em Julia.\n\nPkg.add(\"SQLite\")  # Instala o pacote SQLite.\nPkg.add(\"DataFrames\")  # Instala o pacote DataFrames.\nPkg.add(\"CSV\")  # Instala o pacote CSV.\n\nusing SQLite, CSV, DataFrames  # Carrega os pacotes SQLite, CSV e DataFrames para uso no código."
  },
  {
    "objectID": "Tutoriais/TSQLite.html#algumas-operações-básicas",
    "href": "Tutoriais/TSQLite.html#algumas-operações-básicas",
    "title": "Um pouco mais sobre SQLite em Julia",
    "section": "Algumas Operações Básicas",
    "text": "Algumas Operações Básicas\nAgora, utilizaremos o famoso conjunto de dados iris do R, porém, executando consultas SQL diretamente no ambiente Julia!\n\nExportar iris do R para CSV\n\nwrite.csv(iris, \"iris.csv\", row.names = FALSE)\n\nImportando o CSV para o banco SQLite via Julia e visualizando suas tabelas e colunas:\n\nusing SQLite, CSV, DataFrames\n\n# Conectar ao banco de dados SQLite\ndb = SQLite.DB(\"meu_banco.sqlite\")\n\n# Carregar o arquivo iris.csv no DataFrame do Julia\niris_df = CSV.read(\"iris.csv\", DataFrame)\n\n# Salvar os dados no banco SQLite na tabela \"iris\"\nSQLite.load!(iris_df, db, \"iris\")\n\n# Verificar quais tabelas existem no banco\nprintln(\"Tabelas no banco:\")\nprintln(SQLite.tables(db))\n\n# Visualizar as colunas da tabela iris\nquery = \"SELECT * FROM iris LIMIT 0;\"  # Apenas o cabeçalho\ncolunas = DataFrame(SQLite.Query(db, query))\nprintln(\"Colunas da tabela 'iris':\")\nprintln(names(colunas))\n\nExplicando o código:\nNesta etapa, utilizamos Julia para carregar o conjunto de dados iris, originalmente salvo como um arquivo CSV exportado do R, e importá-lo para um banco de dados SQLite, de forma que possamos fazer consultas SQL sobre ele.\nPrimeiro, carregamos os pacotes SQLite, CSV e DataFrames, que permitem manipular arquivos CSV, criar e interagir com bancos de dados SQLite, e trabalhar com os dados como tabelas em Julia. Em seguida, conectamos (ou criamos) um banco de dados chamado meu_banco.sqlite, que será armazenado como um arquivo local no disco. Após isso, lemos o arquivo iris.csv e o carregamos em um DataFrame — uma estrutura tabular usada em Julia para representar dados como em uma planilha.\nCom os dados já carregados em memória, usamos o comando SQLite.load! para criar uma nova tabela chamada iris dentro do banco SQLite e inserir todos os dados do DataFrame nela. Por fim, usamos SQLite.tables(db) para listar todas as tabelas presentes no banco e confirmar que a importação foi bem-sucedida.\nEssa etapa transforma os dados do R em uma base SQL pronta para consultas, combinando o poder do SQLite com a flexibilidade da linguagem Julia.\n\n\nManipulação Básica: Selecionando Registros\n\nO comando dbGetQuery consulta o banco de dados, extrai os resultados solicitados e os retorna para o ambiente Julia.\nA sintaxe é: dbGetQuery(conexao, \"sua instrução SQL aqui\").\nTarefa: Extraia todo o conteúdo da tabela albums e armazene o resultado em um objeto chamado album_db.\n\n\n# Consulta SQL para selecionar todas as colunas e linhas da tabela 'iris'\nquery = \"SELECT * FROM iris\"\n\n# Executa a consulta e armazena o resultado no objeto iris_db como um DataFrame\niris_db = DataFrame(SQLite.Query(db, query))\n\n# Visualiza o conteúdo (opcional)\nprintln(iris_db)\n\nNeste código, a extração de todos os dados da tabela iris é realizada por meio da consulta SQL SELECT * FROM iris. A função SQLite.Query executa essa consulta no banco de dados, e o resultado é então utilizado para construir um DataFrame. O objeto resultante, chamado iris_db, armazena os dados em uma estrutura tabular no ambiente Julia, pronta para análise.\nEssa operação é análoga à função dbGetQuery da linguagem R.\n\n\nO Comando SELECT\nO comando SELECT é a instrução mais utilizada em SQL e pode ser combinado com diversas cláusulas para refinar as consultas:\n\nORDER BY: Ordenar os resultados.\n\n\n  query = \"\"\"\nSELECT *\nFROM iris\nORDER BY SepalLength DESC\n\"\"\"\nresultado = DataFrame(SQLite.Query(db, query))\nprintln(resultado)\n\nOrdena os dados da tabela iris do maior para o menor valor de SepalLength.\n\nDISTINCT: valores únicos.\n\n\nquery = \"\"\"\nSELECT DISTINCT Species\nFROM iris\n\"\"\"\nresultado = DataFrame(SQLite.Query(db, query))\nprintln(resultado)\n\nRetorna as espécies únicas presentes no conjunto iris.\n\nWHERE: filtrar linhas.\n\n\nquery = \"\"\"\nSELECT *\nFROM iris\nWHERE Species = 'setosa'\n\"\"\"\nresultado = DataFrame(SQLite.Query(db, query))\nprintln(resultado)\n\nFiltra apenas as linhas onde a espécie é setosa.\n\nLIMIT: limitar número de resultados.\n\n\nquery = \"\"\"\nSELECT *\nFROM iris\nLIMIT 10\n\"\"\"\nresultado = DataFrame(SQLite.Query(db, query))\nprintln(resultado)\n\nMostra apenas as 10 primeiras linhas da tabela.\n\nGROUP BY: agrupar linhas que têm os mesmos valores em colunas especificadas.\nHAVING: filtrar os resultados de um agrupamento com base em uma condição.\n\n\nquery = \"\"\"\nSELECT Species, AVG(SepalLength) as MediaSepal\nFROM iris\nGROUP BY Species\nHAVING MediaSepal &gt; 5.5\n\"\"\"\nresultado = DataFrame(SQLite.Query(db, query))\nprintln(resultado)\n\nAgrupa por espécie, calcula a média de SepalLength e exibe apenas as espécies com média acima de 5.\n\nJOIN: consultar múltiplas tabelas.\n\nComo estamos trabalhando apenas com a tabela iris, o exemplo de JOIN não se aplica diretamente aqui. Para um exemplo prático, seria necessário criar uma segunda tabela relacionada e então utilizar o JOIN para combinar os dados de ambas."
  },
  {
    "objectID": "Tutoriais/TSQLite.html#funções-de-agregação",
    "href": "Tutoriais/TSQLite.html#funções-de-agregação",
    "title": "Um pouco mais sobre SQLite em Julia",
    "section": "Funções de Agregação",
    "text": "Funções de Agregação\n\nAVG\nAVG(\\[ALL \\| DISTINCT\\] expressao) - Calcula o valor médio de uma expressão numérica. Por padrão, considera todos os valores não nulos. Se DISTINCT for especificado, calcula a média apenas dos valores únicos.\n\n\nCOUNT\nCOUNT(\\[ALL \\| DISTINCT\\] expressao) - Realiza a contagem de itens. COUNT(*) retorna o número total de linhas de uma tabela. COUNT(coluna) retorna a quantidade de valores não nulos em uma coluna específica.\n\n\nMAX, MIN, SUM\nEstas funções operam de maneira similar, retornando um único valor a partir de um conjunto de linhas:\n\nMAX(expressao): Retorna o maior valor.\nMIN(expressao): Retorna o menor valor.\nSUM(expressao): Retorna a soma de todos os valores."
  },
  {
    "objectID": "Tutoriais/TSQLite.html#boas-práticas",
    "href": "Tutoriais/TSQLite.html#boas-práticas",
    "title": "Um pouco mais sobre SQLite em Julia",
    "section": "Boas Práticas:",
    "text": "Boas Práticas:\nAo trabalhar com bancos de dados, uma das principais preocupações é garantir que as consultas sejam executadas com segurança, evitando falhas e, principalmente, vulnerabilidades como a Injeção de SQL (SQL Injection).\nNo R, por exemplo, o pacote RSQLite oferece funções como dbSendQuery() e dbBind(). Elas permitem preparar uma consulta com parâmetros e, em um segundo passo, passar os valores de forma segura. Essa abordagem, conhecida como consulta parametrizada, é muito mais robusta do que interpolar valores diretamente na string SQL.\nEmbora estejamos utilizando Julia, o conceito fundamental permanece o mesmo: evite construir consultas SQL por meio da concatenação de strings que contenham dados inseridos pelo usuário. A prática recomendada é sempre utilizar consultas parametrizadas. Vale notar que, embora o pacote SQLite.jl ainda possa ter limitações no suporte nativo a esse recurso, é possível implementar soluções seguras com um cuidado adicional.\n\nO Que Deve Ser Evitado\n\nA construção de consultas pela interpolação direta de variáveis em uma string é uma prática perigosa.\n\n\n# NÃO FAÇA: Inserindo valor diretamente na string SQL\nnome_especie = \"setosa\"\nquery = \"SELECT * FROM iris WHERE Species = '$nome_especie'\"\n\nIsso pode parecer inofensivo com entradas controladas, mas abre uma brecha grave para manipulação maliciosa (Injeção de SQL) se o valor da variável vier de uma fonte externa, como um formulário web.\n\n\nA Abordagem Correta (Exemplo com RSQLite)\n\nA boa prática consiste em usar consultas parametrizadas, onde a instrução SQL é enviada com um placeholder (?), e os valores são enviados separadamente.\n\n\n# Em R, utilizando dbBind para evitar injeção\nstmt &lt;- dbSendQuery(conexao, \"SELECT * FROM iris WHERE Species = ?\")\ndbBind(stmt, list(\"setosa\"))\n\nQuando uma consulta SQL é executada, o método de inserção de dados afeta diretamente a segurança da operação. Em uma consulta segura, os dados são mantidos separados da instrução SQL por meio de placeholders (marcadores de posição, como ? ou :param). Os valores são então passados de forma isolada, eliminando a possibilidade de injeção de SQL. Isso significa que, mesmo que o valor inserido por um usuário seja malicioso, ele será tratado apenas como um dado literal e nunca como parte do comando SQL, garantindo a proteção do banco de dados.\nPor outro lado, em uma consulta insegura, os valores são concatenados diretamente na string da consulta. Essa abordagem abre uma vulnerabilidade crítica para ataques de injeção de SQL, nos quais um invasor pode manipular a consulta para executar comandos indesejados, como apagar tabelas ou extrair dados sensíveis.\nPortanto, a recomendação é categórica: sempre que possível, utilize consultas parametrizadas. Essa prática garante que os dados sejam tratados corretamente, minimizando riscos e mantendo a integridade e a segurança do banco de dados."
  },
  {
    "objectID": "Tutoriais/TSQLite.html#fechando-conexões",
    "href": "Tutoriais/TSQLite.html#fechando-conexões",
    "title": "Um pouco mais sobre SQLite em Julia",
    "section": "Fechando Conexões",
    "text": "Fechando Conexões\nAo utilizar o pacote _JuliaCall_ no RStudio para executar comandos em Julia, as boas práticas de gerenciamento de conexões com bancos de dados são as mesmas de um ambiente Julia nativo. Ou seja, após concluir suas operações, é fundamental garantir que a conexão com o banco de dados seja devidamente encerrada e que quaisquer arquivos temporários sejam removidos.\nPara realizar essas tarefas, as seguintes funções do Julia podem ser utilizadas:\n\nclose(conexao): Fecha a conexão ativa com o banco de dados SQLite.\nrm(\"caminho_do_arquivo\"): Remove o arquivo especificado do disco."
  },
  {
    "objectID": "Tutoriais/TSQLite.html#considerações-finais",
    "href": "Tutoriais/TSQLite.html#considerações-finais",
    "title": "Um pouco mais sobre SQLite em Julia",
    "section": "Considerações Finais",
    "text": "Considerações Finais\nNeste tutorial, exploramos como integrar o SQLite com Julia no RStudio, permitindo realizar operações SQL de forma eficiente em um banco de dados leve e sem servidor. Vimos como importar dados, realizar consultas básicas (como SELECT, ORDER BY, WHERE), inserir dados em tabelas e aplicar boas práticas de segurança para evitar injeção de SQL.\nDestacamos a importância de fechar conexões adequadamente após as operações para otimizar recursos. O SQLite é ideal para aplicações que necessitam de um banco de dados simples e portátil, e a combinação com Julia oferece flexibilidade para análise de dados e manipulação avançada.\nCom o que foi aprendido, você pode expandir suas habilidades explorando mais funcionalidades do SQLite e Julia, criando soluções eficientes e seguras para trabalhar com bancos de dados locais. ::: {.callout-note} Ferramentas de IA foram utilizadas para correção ortográfica e aprimoramento do texto. :::"
  },
  {
    "objectID": "Tutoriais/TSQLite.html#configuração-do-ambiente-rstudio-com-julia",
    "href": "Tutoriais/TSQLite.html#configuração-do-ambiente-rstudio-com-julia",
    "title": "Um pouco mais sobre SQLite em Julia",
    "section": "Configuração do Ambiente: RStudio com Julia",
    "text": "Configuração do Ambiente: RStudio com Julia\nComo o RStudio será utilizado para este projeto, é preciso instalar o pacote correspondente da linguagem Julia.\n\ninstall.packages(\"JuliaCall\")\n\n\nSys.setenv(JULIA_HOME = \"\")\njulia_setup()\n\nCaso surja alguma dúvida durante este processo, temos um blog que pode ajudar: https://ime.unicamp.br/julialang/Blog/julia_rstudio.html"
  }
]